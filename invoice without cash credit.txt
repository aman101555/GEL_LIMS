// Update your GenerateInvoice.jsx component this is jus a fucntion 

import { useState, useEffect } from "react";
import axios from "axios";

export default function GenerateInvoice() {
  const [formData, setFormData] = useState({
    project_id: "",
    invoice_type: "CASH",
    document_type: "PROFORMA" // PROFORMA, TAX, or DELIVERY_NOTE
  });
  
  const [availableProjects, setAvailableProjects] = useState([]);
  const [loading, setLoading] = useState(false);
  const [invoiceLoading, setInvoiceLoading] = useState(false);
  const [deliveryNoteLoading, setDeliveryNoteLoading] = useState(false);
  const [message, setMessage] = useState("");
  const [selectedProjectData, setSelectedProjectData] = useState(null);
  const [availableReports, setAvailableReports] = useState([]);
  const [selectedReports, setSelectedReports] = useState([]);
  const [selectAllReports, setSelectAllReports] = useState(true);

  // Fetch latest projects
  useEffect(() => {
    fetchAvailableProjects();
  }, []);

  // Fetch reports when project is selected for PROFORMA, TAX, or DELIVERY_NOTE
  useEffect(() => {
    if (formData.project_id && ['PROFORMA', 'TAX', 'DELIVERY_NOTE'].includes(formData.document_type)) {
      fetchReportsForDocument();
    } else {
      setAvailableReports([]);
      setSelectedReports([]);
    }
  }, [formData.project_id, formData.document_type]);

  const fetchAvailableProjects = async () => {
    setLoading(true);
    try {
      const response = await axios.get("http://localhost:8000/invoices/projects/latest/");
      setAvailableProjects(response.data);
    } catch (error) {
      console.error("Error fetching projects:", error);
      setMessage("‚ùå Failed to load projects. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  const fetchReportsForDocument = async () => {
    try {
      console.log("Fetching reports for:", {
        project: formData.project_id,
        document_type: formData.document_type
      });
      
      let response;
      
      if (formData.document_type === "DELIVERY_NOTE") {
        response = await axios.get(
          `http://localhost:8000/invoices/projects/${formData.project_id}/reports-for-delivery`
        );
      } else {
        // For PROFORMA or TAX
        response = await axios.get(
          `http://localhost:8000/invoices/projects/${formData.project_id}/reports-for-invoice/${formData.document_type}`
        );
      }
      
      console.log("Reports response:", response.data);
      
      setAvailableReports(response.data.reports || []);
      
      // Select only uninvoiced reports by default
      const uninvoicedReportIds = (response.data.reports || [])
        .filter(report => !report.already_invoiced)
        .map(report => report.report_id);
      
      console.log("Uninvoiced report IDs:", uninvoicedReportIds);
      
      setSelectedReports(uninvoicedReportIds);
      setSelectAllReports(uninvoicedReportIds.length > 0);
      
    } catch (error) {
      console.error("Error fetching reports:", error);
      console.error("Error details:", error.response?.data);
      setAvailableReports([]);
      setMessage("‚ùå Failed to load reports: " + (error.response?.data?.detail || error.message));
    }
  };

  const handleProjectChange = (e) => {
    const projectId = e.target.value;
    setFormData({ ...formData, project_id: projectId });
    
    const project = availableProjects.find(p => p.project_id == projectId);
    setSelectedProjectData(project || null);
  };

  const handleDocumentTypeChange = (type) => {
    setFormData({ ...formData, document_type: type });
  };

  const handleReportSelection = (reportId) => {
    // Don't allow selection of already invoiced reports
    const report = availableReports.find(r => r.report_id === reportId);
    if (report && report.already_invoiced) {
      return; // Do nothing for already invoiced reports
    }
    
    setSelectedReports(prev => {
      if (prev.includes(reportId)) {
        return prev.filter(id => id !== reportId);
      } else {
        return [...prev, reportId];
      }
    });
  };

  const handleSelectAllReports = (checked) => {
    setSelectAllReports(checked);
    if (checked) {
      // Only select UNINVOICED reports
      const uninvoicedReportIds = availableReports
        .filter(report => !report.already_invoiced)
        .map(report => report.report_id);
      setSelectedReports(uninvoicedReportIds);
    } else {
      setSelectedReports([]);
    }
  };

  const handleGenerateInvoice = async (e) => {
    e.preventDefault();
    
    if (!formData.project_id) {
      setMessage("‚ùå Please select a project first");
      return;
    }

    if (formData.document_type === "DELIVERY_NOTE") {
      await generateDeliveryNote();
    } else {
      await generateInvoice();
    }
  };

  const generateInvoice = async () => {
  setInvoiceLoading(true);
  setMessage("");

  try {
    let payload;
    
    if (formData.document_type === "PROFORMA" || formData.document_type === "TAX") {
      // FIX: Use document_type as invoice_type for PROFORMA/TAX invoices
      payload = {
        project_id: parseInt(formData.project_id),
        invoice_type: formData.document_type,  // This is correct: "PROFORMA" or "TAX"
        document_type: formData.document_type, // Add this for the backend
        invoice_date: new Date().toISOString().split('T')[0],
        payment_terms: formData.invoice_type === "CREDIT" ? "30 days" : "Immediate",
        services_description: "Professional services rendered",
        // Report selection data
        selected_report_ids: selectAllReports ? null : selectedReports,
        include_all_reports: selectAllReports
      };
      
      console.log("Sending invoice payload with reports:", payload);
      
      // Use the new combined endpoint
      const response = await axios.post(
        "http://localhost:8000/invoices/generate-with-reports",
        payload,
        { responseType: 'blob' }
      );
        
        // Trigger download
        const url = window.URL.createObjectURL(new Blob([response.data]));
        const link = document.createElement('a');
        link.href = url;
        
        // Get filename from Content-Disposition header or use default
        const contentDisposition = response.headers['content-disposition'];
        let filename = `${formData.document_type}-Invoice.xlsx`;
        if (contentDisposition) {
          const filenameMatch = contentDisposition.match(/filename="?(.+)"?/);
          if (filenameMatch && filenameMatch[1]) {
            filename = filenameMatch[1];
          }
        }
        
        link.setAttribute('download', filename);
        document.body.appendChild(link);
        link.click();
        link.remove();
        
        window.URL.revokeObjectURL(url);
        
      } else {
        // Original logic for CASH invoices (no report selection)
        const invoicePayload = {
          project_id: parseInt(formData.project_id),
          invoice_type: formData.invoice_type,
          invoice_date: new Date().toISOString().split('T')[0],
          payment_terms: formData.invoice_type === "CREDIT" ? "30 days" : "Immediate",
          services_description: "Professional services rendered"
        };

        const createResponse = await axios.post(
          "http://localhost:8000/invoices/",
          invoicePayload
        );

        const invoiceId = createResponse.data.invoice_id;
        
        // Generate Excel
        const excelResponse = await axios.get(
          `http://localhost:8000/invoices/${invoiceId}/excel`,
          { responseType: 'blob' }
        );

        // Trigger download
        const url = window.URL.createObjectURL(new Blob([excelResponse.data]));
        const link = document.createElement('a');
        link.href = url;
        link.setAttribute('download', `Invoice-${createResponse.data.invoice_no}.xlsx`);
        document.body.appendChild(link);
        link.click();
        link.remove();
        
        window.URL.revokeObjectURL(url);
      }
      
      setMessage(`‚úÖ ${formData.document_type === "TAX" ? "Tax" : formData.document_type === "PROFORMA" ? "Proforma" : "Invoice"} generated successfully!`);
      
    } catch (error) {
      console.error("Error generating invoice:", error);
      let errorMsg = "‚ùå An unexpected error occurred";
      if (error.response) {
        errorMsg = `‚ùå ${error.response.data?.detail || error.response.statusText}`;
      } else if (error.request) {
        errorMsg = "‚ùå Network error. Please check if the server is running.";
      } else {
        errorMsg = `‚ùå ${error.message}`;
      }
      setMessage(errorMsg);
    } finally {
      setInvoiceLoading(false);
    }
  };

  const generateDeliveryNote = async () => {
    setDeliveryNoteLoading(true);
    setMessage("");

    try {
      const payload = {
        project_id: parseInt(formData.project_id),
        ...(selectAllReports ? {} : { selected_report_ids: selectedReports }),
        include_all_reports: selectAllReports
      };

      console.log("Sending delivery note payload:", payload);

      const response = await axios.post(
        "http://localhost:8000/invoices/delivery-notes/generate-excel-template",
        payload,
        { responseType: 'blob' }
      );

      // Trigger download
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      
      const contentDisposition = response.headers['content-disposition'];
      let filename = 'Delivery-Note.xlsx';
      if (contentDisposition) {
        const filenameMatch = contentDisposition.match(/filename="?(.+)"?/);
        if (filenameMatch && filenameMatch[1]) {
          filename = filenameMatch[1];
        }
      }
      
      link.setAttribute('download', filename);
      document.body.appendChild(link);
      link.click();
      link.remove();
      
      window.URL.revokeObjectURL(url);
      
      setMessage("‚úÖ Delivery Note generated successfully!");
      
    } catch (error) {
      console.error("Error generating delivery note:", error);
      let errorMsg = "‚ùå Failed to generate delivery note";
      if (error.response) {
        console.error("Server response:", error.response.data);
        errorMsg = `‚ùå ${error.response.data?.detail || error.response.statusText || 'Unknown error'}`;
      } else if (error.request) {
        errorMsg = "‚ùå Network error. Please check if the server is running.";
      } else {
        errorMsg = `‚ùå ${error.message}`;
      }
      setMessage(errorMsg);
    } finally {
      setDeliveryNoteLoading(false);
    }
  };

  // Determine which document type options to show based on invoice type
  const getDocumentTypeOptions = () => {
    if (formData.invoice_type === "CASH") {
      return [
        { value: "PROFORMA", label: "üìÑ Generate Proforma Invoice" },
        { value: "TAX", label: "üí∞ Generate Tax Invoice" }
      ];
    } else { // CREDIT
      return [
        { value: "DELIVERY_NOTE", label: "üìã Generate Delivery Notes" },
        { value: "PROFORMA", label: "üìÑ Generate Proforma Invoice" },
        { value: "TAX", label: "üí∞ Generate Tax Invoice" }
      ];
    }
  };

  // Check if current document type shows report selection
  const showReportSelection = () => {
    return ['PROFORMA', 'TAX', 'DELIVERY_NOTE'].includes(formData.document_type);
  };

  return (
    <div className="module-content">
      <div className="module-header">
        <h2>Generate Invoices</h2>
      </div>
      
      <div className="form-section">
        <h3>Generate Invoices from Project</h3>
        
        {message && (
          <div className={`message ${message.includes('‚úÖ') ? 'success' : 'error'}`}>
            {message}
          </div>
        )}

        <form onSubmit={handleGenerateInvoice} className="sample-form">
          {/* SELECT PROJECT */}
          <div className="form-group">
            <label htmlFor="project-id">Select Project *</label>
            <select
              id="project-id"
              value={formData.project_id}
              onChange={handleProjectChange}
              className="form-input"
              required
              disabled={invoiceLoading || loading || deliveryNoteLoading}
            >
              <option value="">Select a Project</option>
              {availableProjects.map((project) => (
                <option key={project.project_id} value={project.project_id}>
                  {project.label}
                </option>
              ))}
            </select>
            <small className="field-hint">
              Select a project to generate invoice
            </small>
          </div>

          {/* INVOICE TYPE */}
          <div className="form-group">
            <label>Invoice Type *</label>
            <div className="invoice-type-buttons">
              {[
                { value: "CASH", label: "üíµ Cash Invoice" },
                { value: "CREDIT", label: "üí≥ Credit Invoice" }
              ].map((type) => (
                <button
                  key={type.value}
                  type="button"
                  onClick={() => setFormData({
                    ...formData, 
                    invoice_type: type.value,
                    // Reset document type when changing invoice type
                    document_type: type.value === "CASH" ? "PROFORMA" : "DELIVERY_NOTE"
                  })}
                  className={`invoice-type-btn ${
                    formData.invoice_type === type.value ? "active" : ""
                  }`}
                >
                  {type.label}
                </button>
              ))}
            </div>
          </div>

          {/* DOCUMENT TYPE */}
          <div className="form-group">
            <label>Document Type *</label>
            <div className="document-type-buttons">
              {getDocumentTypeOptions().map((type) => (
                <button
                  key={type.value}
                  type="button"
                  onClick={() => handleDocumentTypeChange(type.value)}
                  className={`document-type-btn ${
                    formData.document_type === type.value ? "active" : ""
                  }`}
                >
                  {type.label}
                </button>
              ))}
            </div>
          </div>

          {/* SELECTED PROJECT DETAILS */}
          {selectedProjectData && (
            <div className="selected-project-details">
              <h4>Selected Project Details</h4>
              <div className="details-grid">
                <div className="detail-card">
                  <p className="detail-label">üìÅ Project No</p>
                  <p className="detail-value">{selectedProjectData.project_no}</p>
                </div>
                <div className="detail-card">
                  <p className="detail-label">üë§ Client</p>
                  <p className="detail-value">{selectedProjectData.client_name}</p>
                </div>
                <div className="detail-card">
                  <p className="detail-label">üìç Location</p>
                  <p className="detail-value">{selectedProjectData.location}</p>
                </div>
              </div>
            </div>
          )}

          {/* REPORTS SELECTION FOR PROFORMA, TAX, AND DELIVERY NOTES */}
          {showReportSelection() && availableReports.length > 0 && (
            <div className="reports-selection-section">
              <h4>
                Select Reports for{" "}
                {formData.document_type === "PROFORMA" ? "Proforma Invoice" :
                 formData.document_type === "TAX" ? "Tax Invoice" : 
                 "Delivery Note"}
              </h4>
              
              {/* Select All checkbox */}
              <div className="select-all-checkbox">
                <label>
                  <input
                    type="checkbox"
                    checked={selectAllReports}
                    onChange={(e) => handleSelectAllReports(e.target.checked)}
                  />
                  Select All {availableReports.filter(r => !r.already_invoiced).length} Uninvoiced reports
                  {availableReports.filter(r => r.already_invoiced).length > 0 && (
                    <span className="invoiced-count">
                      ({availableReports.filter(r => r.already_invoiced).length} already{" "}
                      {formData.document_type === "DELIVERY_NOTE" ? "delivered" : "invoiced"} - excluded)
                    </span>
                  )}
                </label>
              </div>

              <div className="reports-list">
                {availableReports.map(report => (
                  <div 
                    key={report.report_id} 
                    className={`report-item ${report.already_invoiced ? 'invoiced disabled' : ''}`}
                    title={report.already_invoiced ? 
                      `Already included in previous ${formData.document_type === "DELIVERY_NOTE" ? "delivery note" : formData.document_type.toLowerCase()} invoice` : 
                      ""}
                  >
                    <label>
                      <input
                        type="checkbox"
                        checked={report.already_invoiced ? false : (selectAllReports || selectedReports.includes(report.report_id))}
                        onChange={() => handleReportSelection(report.report_id)}
                        disabled={report.already_invoiced}
                      />
                      <span className="report-info">
                        <strong>{report.report_no}</strong> - {report.test_name}
                        <span className="report-meta">
                          {report.sample_count} Test(s) ‚Ä¢ {report.created_date}
                          {report.already_invoiced && (
                            <span className="invoiced-badge">
                              * {formData.document_type === "DELIVERY_NOTE" ? "Delivered" : "Invoiced"}
                            </span>
                          )}
                        </span>
                      </span>
                    </label>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* ACTION BUTTON */}
          <div className="action-buttons">
            <button 
              type="submit" 
              className="btn-primary"
              disabled={
                (invoiceLoading || deliveryNoteLoading || !formData.project_id) ||
                (showReportSelection() && selectedReports.length === 0 && !selectAllReports)
              }
            >
              {invoiceLoading || deliveryNoteLoading ? (
                <>
                  <span className="spinner"></span>
                  {formData.document_type === "DELIVERY_NOTE" 
                    ? "Generating Delivery Note..." 
                    : formData.document_type === "PROFORMA"
                    ? "Generating Proforma Invoice..."
                    : formData.document_type === "TAX"
                    ? "Generating Tax Invoice..."
                    : "Generating Invoice..."}
                </>
              ) : (
                formData.document_type === "DELIVERY_NOTE"
                  ? "Generate & Download Delivery Note"
                  : formData.document_type === "PROFORMA"
                  ? "Generate & Download Proforma Invoice"
                  : formData.document_type === "TAX"
                  ? "Generate & Download Tax Invoice"
                  : "Generate & Download Invoice"
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}


















































































####################################################################################################################################################################################




























# invoices.py - COMPLETE FIXED VERSION
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, List, Literal
from datetime import date, datetime
from db import get_connection
from decimal import Decimal
from fastapi.responses import HTMLResponse
import traceback


import openpyxl
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side

from fastapi.responses import FileResponse
import openpyxl
from datetime import datetime
import os

router = APIRouter(prefix="/invoices", tags=["6. Invoices"])

# ----------------------------
# Pydantic Models
# ----------------------------
class InvoiceItemCreate(BaseModel):
    quotation_item_id: int
    quantity: int = 1
    sample_id: Optional[int] = None

class InvoiceCreate(BaseModel):
    project_id: int
    invoice_type: Literal['CASH', 'CREDIT','PROFORMA', 'TAX']
    invoice_date: Optional[date] = None
    client_reference: Optional[str] = None
    lpo_reference: Optional[str] = None
    lpo_date: Optional[date] = None
    payment_terms: Optional[str] = "30 days"
    services_description: Optional[str] = None
    remarks: Optional[str] = None

class InvoiceOut(BaseModel):
    invoice_id: int
    invoice_no: str
    project_id: int
    invoice_type: str
    invoice_date: date
    client_reference: Optional[str]
    lpo_reference: Optional[str]
    lpo_date: Optional[date]
    payment_terms: Optional[str]
    subtotal: float
    vat: float
    total: float
    amount_in_words: str
    services_description: Optional[str]
    remarks: Optional[str]
    payment_status: str
    paid_date: Optional[date]
    items: List[dict]
    project_details: dict


# =====================================================
# NEW: Models for Invoice Reports
# =====================================================
class InvoiceReportSelection(BaseModel):
    project_id: int
    selected_report_ids: Optional[List[int]] = None
    include_all_reports: bool = True
    invoice_type: Literal['PROFORMA', 'TAX']  # New field

# ----------------------------
# Utility Functions - FIXED
# ----------------------------
# ----------------------------
# Utility Functions - FIXED
# ----------------------------
def number_to_words(num: float) -> str:
    """Convert number to words for amount in words field"""
    # First, separate whole dirhams and fils
    whole_part = int(num)
    decimal_part = round((num - whole_part) * 100)
    
    def convert_less_than_thousand(n):
        ones = ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
        teens = ["Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", 
                 "Seventeen", "Eighteen", "Nineteen"]
        tens = ["", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]
        
        if n == 0:
            return ""
        elif n < 10:
            return ones[n]
        elif n < 20:
            return teens[n - 10]
        elif n < 100:
            return tens[n // 10] + (" " + ones[n % 10] if n % 10 != 0 else "")
        else:
            return ones[n // 100] + " Hundred" + (" " + convert_less_than_thousand(n % 100) if n % 100 != 0 else "")
    
    if whole_part == 0:
        words = "Zero"
    else:
        # Handle millions
        millions = whole_part // 1000000
        remainder = whole_part % 1000000
        
        # Handle thousands
        thousands = remainder // 1000
        remainder = remainder % 1000
        
        words_parts = []
        
        if millions > 0:
            words_parts.append(convert_less_than_thousand(millions) + " Million")
        
        if thousands > 0:
            words_parts.append(convert_less_than_thousand(thousands) + " Thousand")
        
        if remainder > 0:
            words_parts.append(convert_less_than_thousand(remainder))
        
        words = " and ".join(words_parts)
        
        # Capitalize first letter
        words = words.strip()
    
    # Add decimal part if exists
    if decimal_part > 0:
        result = f"{words} Dirhams and {convert_less_than_thousand(decimal_part)} Fils Only"
    else:
        result = f"{words} Dirhams Only"
    
    return result

def generate_invoice_no(cur, invoice_type: str) -> str:
    """Generate invoice number with different systems for PROFORMA vs other invoices"""
    # Get the last 2 digits of current year
    year_short = str(datetime.now().year)[-2:]
    
    print(f"DEBUG generate_invoice_no: invoice_type='{invoice_type}', year_short='{year_short}'")
    
    # SPECIAL CASE FOR PROFORMA INVOICES - Reset each year starting from 001
    if invoice_type.upper() == 'PROFORMA':
        print("DEBUG: Generating PROFORMA invoice number")
        
        # Get the last PROFORMA invoice number for this year
        cur.execute("""
            SELECT invoice_no 
            FROM invoices 
            WHERE invoice_type = 'PROFORMA'
            AND invoice_no LIKE %s
            ORDER BY invoice_id DESC 
            LIMIT 1
        """, (f'%/{year_short}',))
        
        last_proforma = cur.fetchone()
        print(f"DEBUG: Last PROFORMA invoice found: {last_proforma}")
        
        if last_proforma and last_proforma[0]:
            try:
                # Get the number part
                last_number_str = last_proforma[0].split('/')[0]
                last_number = int(last_number_str)
                
                # If it's a new format invoice (001, 002, etc.), increment normally
                if last_number <= 999:
                    next_number = last_number + 1
                    invoice_no = f"{next_number:03d}/{year_short}"
                    print(f"DEBUG: Incremented new format PROFORMA: {last_number} -> {next_number}")
                else:
                    # Old format invoice, start new format from 001
                    next_number = 1
                    invoice_no = f"{next_number:03d}/{year_short}"
                    print(f"DEBUG: Old format found, starting new format from 001")
            except (ValueError, IndexError):
                # If parsing fails, start from 001
                next_number = 1
                invoice_no = f"{next_number:03d}/{year_short}"
                print(f"DEBUG: Parse failed, starting from 001")
        else:
            # No PROFORMA invoice for this year yet, start from 001
            next_number = 1
            invoice_no = f"{next_number:03d}/{year_short}"
            print(f"DEBUG: No existing PROFORMA, starting from 001")
        
        print(f"DEBUG: Generated PROFORMA invoice_no: {invoice_no}")
        return invoice_no
    
    # ORIGINAL LOGIC FOR OTHER INVOICE TYPES (CASH, CREDIT, TAX)
    print(f"DEBUG: Generating non-PROFORMA invoice number for type: {invoice_type}")
    
    # Get the max invoice number overall for non-PROFORMA invoices
    cur.execute("""
        SELECT invoice_no 
        FROM invoices 
        WHERE invoice_type != 'PROFORMA'
        ORDER BY invoice_id DESC 
        LIMIT 1
    """)
    
    last_invoice = cur.fetchone()
    print(f"DEBUG: Last non-PROFORMA invoice found: {last_invoice}")
    
    if last_invoice and last_invoice[0]:
        # Parse existing invoice number
        try:
            last_number_str = last_invoice[0].split('/')[0]
            last_number = int(last_number_str)
            next_number = last_number + 1
            print(f"DEBUG: Parsed last non-PROFORMA number: {last_number}, next: {next_number}")
        except (ValueError, IndexError) as e:
            print(f"DEBUG: Failed to parse non-PROFORMA number '{last_invoice[0]}': {e}")
            # If parsing fails, start from 36001
            next_number = 36001
    else:
        # First invoice ever (non-PROFORMA)
        print("DEBUG: First non-PROFORMA invoice ever")
        next_number = 36001
    
    invoice_no = f"{next_number}/{year_short}"
    print(f"DEBUG: Generated non-PROFORMA invoice_no: {invoice_no}")
    return invoice_no
def ensure_delivery_note_reports_table(cur):
    """Ensure the delivery_note_reports junction table exists"""
    cur.execute("""
        CREATE TABLE IF NOT EXISTS delivery_note_reports (
            id SERIAL PRIMARY KEY,
            delivery_note_no VARCHAR(50) NOT NULL,
            report_no VARCHAR(50) NOT NULL,  -- Changed from VARCHAR(100) to VARCHAR(50)
            UNIQUE(delivery_note_no, report_no)
        )
    """)
    # Note: removed included_at column since your SQL table doesn't have it


# ----------------------------
# Assignment Logic - SAME AS WORKSHEET GENERATION
# ----------------------------

def get_assigned_test_for_sample(sample_id: int, cur):
    """Get the assigned test for a sample - SAME LOGIC AS WORKSHEET GENERATION"""
    # Get sample's test request
    cur.execute("SELECT request_id FROM samples WHERE sample_id = %s", (sample_id,))
    sample_data = cur.fetchone()
    if not sample_data:
        return None
    
    request_id = sample_data[0]
    
    # Get all tests for this request
    cur.execute("""
        SELECT qi.item_id, qi.item_code, qi.description, qi.test_standard, qi.unit_rate,
               tri.quantity, tri.tri_id,
               ROW_NUMBER() OVER (ORDER BY tri.tri_id) as test_index
        FROM test_request_items tri
        JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
        WHERE tri.test_request_id = %s
        ORDER BY tri.tri_id
    """, (request_id,))
    
    test_items = cur.fetchall()
    
    if not test_items:
        return None
    
    # Get all samples for this request to find position
    cur.execute("SELECT sample_id FROM samples WHERE request_id = %s ORDER BY sample_id", (request_id,))
    all_samples = [row[0] for row in cur.fetchall()]
    
    # ‚úÖ SAME LOGIC AS WORKSHEET: Calculate assigned test
    sample_position = all_samples.index(sample_id)
    assigned_test_index = sample_position % len(test_items)
    
    return test_items[assigned_test_index]


def get_project_quotation_items(project_id: int, cur):
    """Get invoiceable items - USING EXACT WORKSHEET LOGIC"""
    # Get all samples for this project
    cur.execute("""
        SELECT s.sample_id 
        FROM projects p
        JOIN test_requests tr ON p.project_id = tr.project_id
        JOIN samples s ON tr.test_request_id = s.request_id
        WHERE p.project_id = %s
        ORDER BY s.sample_id
    """, (project_id,))
    
    sample_ids = [row[0] for row in cur.fetchall()]
    
    filtered_items = []
    for sample_id in sample_ids:
        assigned_test = get_assigned_test_for_sample(sample_id, cur)
        if assigned_test:
            item_id, item_code, description, test_standard, unit_rate, quantity, tri_id, test_index = assigned_test
            
            # Get sample details
            cur.execute("SELECT sample_no, status FROM samples WHERE sample_id = %s", (sample_id,))
            sample_data = cur.fetchone()
            if sample_data:
                sample_no, sample_status = sample_data
            else:
                sample_no, sample_status = f"SMP-{sample_id}", "PENDING"
            
            # Get test request details
            cur.execute("""
                SELECT tr.test_request_id, tr.request_no 
                FROM test_requests tr 
                WHERE tr.test_request_id = (SELECT request_id FROM samples WHERE sample_id = %s)
            """, (sample_id,))
            request_data = cur.fetchone()
            if request_data:
                test_request_id, request_no = request_data
            else:
                test_request_id, request_no = None, "UNKNOWN"
            
            filtered_items.append((
                item_id, description, test_standard, unit_rate, 1,  # Quantity always 1 per sample
                test_request_id, request_no, sample_id, sample_no, sample_status
            ))
    
    return filtered_items

def get_invoice_complete(invoice_id: int, cur):
    """Get complete invoice details with items - FIXED for PROFORMA/TAX filtered totals"""
    # Get invoice header
    cur.execute("""
        SELECT i.invoice_id, i.invoice_no, i.project_id, i.invoice_type, i.invoice_date,
               i.client_reference, i.lpo_reference, i.lpo_date, i.payment_terms,
               i.subtotal, i.vat, i.total, i.amount_in_words, i.services_description, 
               i.remarks, i.payment_status, i.paid_date,
               p.project_no, p.project_name, p.location,
               c.client_id, c.name, c.contact_person, c.email, c.address, c.phone
        FROM invoices i
        JOIN projects p ON i.project_id = p.project_id
        JOIN clients c ON p.client_id = c.client_id
        WHERE i.invoice_id = %s
    """, (invoice_id,))
    
    header = cur.fetchone()
    if not header:
        raise HTTPException(status_code=404, detail="Invoice not found")
    
    # Get invoice items
    cur.execute("""
        SELECT 
            ii.item_id, 
            ii.description, 
            ii.test_standard, 
            ii.unit_rate, 
            ii.quantity, 
            ii.amount, 
            ii.sample_id, 
            s.sample_no,
            s.status as sample_status,
            tr.request_no,
            tr.test_request_id
        FROM invoice_items ii
        LEFT JOIN samples s ON ii.sample_id = s.sample_id
        LEFT JOIN test_requests tr ON ii.test_request_id = tr.test_request_id
        WHERE ii.invoice_id = %s
        ORDER BY ii.item_id
    """, (invoice_id,))
    
    items_data = cur.fetchall()
    
    # Get invoice type
    invoice_type = header[3]
    
    # =====================================================
    # NEW: For PROFORMA/TAX invoices, filter items by linked reports
    # =====================================================
    if invoice_type in ["PROFORMA", "TAX"]:
        # Get reports linked to this invoice
        cur.execute("""
            SELECT report_no 
            FROM invoice_report_links 
            WHERE invoice_id = %s 
            AND invoice_type = %s
        """, (invoice_id, invoice_type))
        
        linked_reports = [row[0] for row in cur.fetchall()]
        
        if linked_reports:
            # Get test types from linked reports
            cur.execute("""
                SELECT DISTINCT covers_test_type 
                FROM reports 
                WHERE report_no = ANY(%s)
                AND status = 'APPROVED'
            """, (linked_reports,))
            
            linked_test_types = [row[0] for row in cur.fetchall() if row[0]]
            
            print(f"DEBUG: Found {len(linked_test_types)} test types for invoice {invoice_id}")
            print(f"DEBUG: Linked test types: {linked_test_types}")
            
            # Filter items to only include those with matching test types
            filtered_items = []
            for item in items_data:
                item_id, description, test_standard, unit_rate, quantity, amount, sample_id, sample_no, sample_status, request_no, test_request_id = item
                
                # Check if this item's description matches any linked test type
                item_included = False
                for test_type in linked_test_types:
                    if test_type and description and (
                        test_type.lower() == description.lower() or 
                        test_type.lower() in description.lower() or
                        description.lower() in test_type.lower()
                    ):
                        item_included = True
                        break
                
                if item_included:
                    filtered_items.append(item)
                    print(f"DEBUG: Keeping item: {description}")
                else:
                    print(f"DEBUG: Filtering out item: {description}")
            
            # Use filtered items
            items_data = filtered_items
    
    # Build items list
    items_list = []
    filtered_subtotal = 0.0
    
    for item in items_data:
        item_amount = float(item[5]) if isinstance(item[5], Decimal) else item[5]
        filtered_subtotal += item_amount
        
        items_list.append({
            "item_id": item[0],
            "description": item[1],
            "test_standard": item[2],
            "unit_rate": float(item[3]) if isinstance(item[3], Decimal) else item[3],
            "quantity": item[4],
            "amount": item_amount,
            "sample_id": item[6],
            "sample_no": item[7],
            "sample_status": item[8],
            "request_no": item[9],
            "test_request_id": item[10]
        })
    
    # =====================================================
    # NEW: Calculate CORRECT totals for filtered items
    # =====================================================
    if invoice_type in ["PROFORMA", "TAX"] and items_list:
        # Recalculate based on filtered items
        filtered_vat = filtered_subtotal * 0.05
        filtered_total = filtered_subtotal + filtered_vat
        filtered_amount_words = number_to_words(filtered_total)
        
        # Check if different from original
        original_subtotal = float(header[9]) if isinstance(header[9], Decimal) else header[9]
        
        if abs(original_subtotal - filtered_subtotal) > 0.01:
            print(f"DEBUG: Using FILTERED totals for {invoice_type} invoice {invoice_id}")
            print(f"  Original: Subtotal={original_subtotal}")
            print(f"  Filtered: Subtotal={filtered_subtotal}, Total={filtered_total}")
            
            subtotal = filtered_subtotal
            vat = filtered_vat
            total = filtered_total
            amount_words = filtered_amount_words
        else:
            # Use original totals
            subtotal = original_subtotal
            vat = float(header[10]) if isinstance(header[10], Decimal) else header[10]
            total = float(header[11]) if isinstance(header[11], Decimal) else header[11]
            amount_words = header[12]
    else:
        # For other invoice types, use original totals
        subtotal = float(header[9]) if isinstance(header[9], Decimal) else header[9]
        vat = float(header[10]) if isinstance(header[10], Decimal) else header[10]
        total = float(header[11]) if isinstance(header[11], Decimal) else header[11]
        amount_words = header[12]
    
    # Return the complete invoice data
    return {
        "invoice_id": header[0],
        "invoice_no": header[1],
        "project_id": header[2],
        "invoice_type": invoice_type,
        "invoice_date": header[4],
        "client_reference": header[5],
        "lpo_reference": header[6],
        "lpo_date": header[7],
        "payment_terms": header[8],
        "subtotal": subtotal,
        "vat": vat,
        "total": total,
        "amount_in_words": amount_words,
        "services_description": header[13],
        "remarks": header[14],
        "payment_status": header[15],
        "paid_date": header[16],
        "items": items_list,
        "project_details": {
            "project_no": header[17],
            "project_name": header[18],
            "location": header[19],
            "client_name": header[20],
            "client_contact": header[21],
            "client_email": header[22],
            "client_address": header[23],
            "client_phone": header[24]
        },
        # Add these new fields to help frontend understand what's happening
        "is_filtered": invoice_type in ["PROFORMA", "TAX"] and len(items_list) > 0,
        "filtered_item_count": len(items_list),
        "original_total": float(header[11]) if isinstance(header[11], Decimal) else header[11]
    }

# ----------------------------
# CREATE INVOICE - FIXED DATA TYPES AND QUERIES
# ----------------------------
@router.post("/", response_model=InvoiceOut)
def create_invoice(payload: InvoiceCreate):
    """
    Create a new invoice for a project.
    Group invoice items by description, test standard, and unit rate.
    """
    conn = get_connection()
    cur = conn.cursor()

    try:
        # ---------------------------------------------------
        # 1. Get project details with client info
        # ---------------------------------------------------
        cur.execute("""
            SELECT p.project_id, p.project_no, p.project_name, p.location, p.lpo_no, p.lpo_date,
                   c.client_id, c.name, c.contact_person, c.email, c.address, c.phone,
                   q.quotation_no
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            JOIN quotations q ON p.quotation_id = q.quotation_id
            WHERE p.project_id = %s
        """, (payload.project_id,))
        project_data = cur.fetchone()
        if not project_data:
            raise HTTPException(status_code=404, detail="Project not found")

        # ---------------------------------------------------
        # 2. Get invoiceable items from project
        # ---------------------------------------------------
        invoiceable_items = get_project_quotation_items(payload.project_id, cur)
        if not invoiceable_items:
            raise HTTPException(status_code=400, detail="No test items available for invoicing")

        # ---------------------------------------------------
        # 2a. Group invoiceable items by description, test standard, unit rate
        # ---------------------------------------------------
        from collections import defaultdict

        grouped_items = defaultdict(lambda: {
            "description": "",
            "test_standard": "",
            "unit_rate": 0,
            "quantity": 0,
            "sample_ids": []
        })

        for item in invoiceable_items:
            item_id, description, test_standard, unit_rate, quantity, test_request_id, request_no, sample_id, sample_no, sample_status = item
            key = (description, test_standard, unit_rate)
            grouped_items[key]["description"] = description
            grouped_items[key]["test_standard"] = test_standard
            grouped_items[key]["unit_rate"] = unit_rate
            grouped_items[key]["quantity"] += quantity
            grouped_items[key]["sample_ids"].append(sample_id)

        # Convert grouped items to a list
        final_items = []
        for (desc, std, rate), data in grouped_items.items():
            final_items.append((desc, std, rate, data["quantity"], data["sample_ids"]))

        # ---------------------------------------------------
        # 3. Generate invoice number
        # ---------------------------------------------------
        invoice_no = generate_invoice_no(cur, payload.invoice_type)

        # ---------------------------------------------------
        # 4. Calculate totals
        # ---------------------------------------------------
        subtotal = 0.0
        for item in final_items:
            desc, std, unit_rate, quantity, sample_ids = item
            unit_rate_float = float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate
            subtotal += unit_rate_float * quantity

        vat = subtotal * 0.05  # 5% VAT
        total = subtotal + vat
        amount_words = number_to_words(total)

        # ---------------------------------------------------
        # 5. LPO and payment terms
        # ---------------------------------------------------
        lpo_reference = payload.lpo_reference or project_data[4]
        lpo_date = payload.lpo_date or project_data[5]
        payment_terms = payload.payment_terms or "30 days"

        # ---------------------------------------------------
        # 6. Insert invoice header
        # ---------------------------------------------------
        cur.execute("""
            INSERT INTO invoices (
                invoice_no, project_id, invoice_type, invoice_date,
                client_reference, lpo_reference, lpo_date, payment_terms,
                subtotal, vat, total, amount_in_words, services_description, remarks
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING invoice_id
        """, (
            invoice_no,
            payload.project_id,
            payload.invoice_type,
            payload.invoice_date or date.today(),
            payload.client_reference,
            lpo_reference,
            lpo_date,
            payment_terms,
            subtotal,
            vat,
            total,
            amount_words,
            payload.services_description or f"Testing services for {project_data[2]}",
            payload.remarks
        ))
        invoice_id = cur.fetchone()[0]

        # ---------------------------------------------------
        # 7. Insert grouped invoice items
        # ---------------------------------------------------
        for item in final_items:
            description, test_standard, unit_rate, quantity, sample_ids = item
            unit_rate_float = float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate
            amount = unit_rate_float * quantity
            sample_id = sample_ids[0] if sample_ids else None  # representative sample

            cur.execute("""
                INSERT INTO invoice_items (
                    invoice_id, description, test_standard,
                    unit_rate, quantity, amount, sample_id
                )
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (
                invoice_id,
                description,
                test_standard,
                unit_rate_float,
                quantity,
                amount,
                sample_id
            ))

        # ---------------------------------------------------
        # 8. Commit transaction
        # ---------------------------------------------------
        conn.commit()

        # ---------------------------------------------------
        # 9. Return complete invoice
        # ---------------------------------------------------
        return get_invoice_complete(invoice_id, cur)

    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()


# ----------------------------
# LIST INVOICES - FIXED
# ----------------------------
@router.get("/", response_model=List[InvoiceOut])
def list_invoices(limit: int = 100, offset: int = 0):
    conn = get_connection()
    cur = conn.cursor()
# Add debug print in Excel generation function
    try:
        cur.execute("""
            SELECT invoice_id FROM invoices 
            ORDER BY invoice_id DESC 
            LIMIT %s OFFSET %s
        """, (limit, offset))
        
        invoice_ids = [row[0] for row in cur.fetchall()]
        invoices = []
        
        for inv_id in invoice_ids:
            invoices.append(get_invoice_complete(inv_id, cur))
        
        return invoices
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ----------------------------
# GET SINGLE INVOICE
# ----------------------------
@router.get("/{invoice_id}", response_model=InvoiceOut)
def get_invoice(invoice_id: int):
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        return get_invoice_complete(invoice_id, cur)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ----------------------------
# UPDATE PAYMENT STATUS
# ----------------------------
@router.post("/{invoice_id}/payment-status")
def update_payment_status(invoice_id: int, status: str, paid_date: Optional[date] = None):
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            UPDATE invoices 
            SET payment_status = %s, paid_date = %s
            WHERE invoice_id = %s
            RETURNING invoice_id
        """, (status, paid_date, invoice_id))
        
        if not cur.fetchone():
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        conn.commit()
        return {"message": "Payment status updated", "invoice_id": invoice_id, "status": status}
        
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ----------------------------
# GET PROJECT INVOICEABLE ITEMS - FIXED
# ----------------------------
@router.get("/projects/{project_id}/invoiceable-items")
def get_invoiceable_items(project_id: int):
    """Get all items that can be invoiced for a project - FIXED"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        items = get_project_quotation_items(project_id, cur)
        
        return {
            "project_id": project_id,
            "invoiceable_items": [
                {
                    "quotation_item_id": item[0],
                    "description": item[1],
                    "test_standard": item[2],
                    "unit_rate": float(item[3]) if isinstance(item[3], Decimal) else item[3],
                    "quantity": item[4],
                    "test_request_id": item[5],
                    "request_no": item[6],
                    "sample_id": item[7],
                    "sample_no": item[8],
                    "sample_status": item[9]
                }
                for item in items
            ]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()



# Add this import at the top with other imports
from fastapi import Query

# Add this DELETE endpoint after the other endpoints
@router.delete("/{invoice_id}")
def delete_invoice(invoice_id: int):
    """
    Delete an invoice and its items from the database.
    """
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # First, get invoice details for response
        cur.execute("""
            SELECT invoice_no FROM invoices WHERE invoice_id = %s
        """, (invoice_id,))
        
        invoice_data = cur.fetchone()
        if not invoice_data:
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        # Delete invoice items first (foreign key constraint)
        cur.execute("DELETE FROM invoice_items WHERE invoice_id = %s", (invoice_id,))
        
        # Delete the invoice
        cur.execute("DELETE FROM invoices WHERE invoice_id = %s RETURNING invoice_id", (invoice_id,))
        
        if not cur.fetchone():
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        conn.commit()
        
        return {
            "message": f"Invoice {invoice_data[0]} deleted successfully",
            "deleted_invoice_id": invoice_id,
            "invoice_no": invoice_data[0]
        }
        
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()



# ----------------------------
# GET INVOICE AS HTML TABLE
# ----------------------------
@router.get("/{invoice_id}/html-table", response_class=HTMLResponse)
def get_invoice_html_table(invoice_id: int):
    """Get invoice as full rendered HTML page"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        invoice_data = get_invoice_complete(invoice_id, cur)

        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Invoice {invoice_data['invoice_no']}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h2, h3 {{ color: #333; }}
                table {{ width: 100%; border-collapse: collapse; margin-bottom: 20px; }}
                th, td {{ padding: 8px; border: 1px solid #ddd; }}
                th {{ background-color: #f2f2f2; text-align: left; }}
                .right {{ text-align: right; }}
                .center {{ text-align: center; }}
            </style>
        </head>
        <body>
            <h2>INVOICE: {invoice_data['invoice_no']}</h2>

            <h3>Client Information</h3>
            <table>
                <tr><th>Client</th><td>{invoice_data['project_details']['client_name']}</td></tr>
                <tr><th>Contact</th><td>{invoice_data['project_details']['client_contact']}</td></tr>
                <tr><th>Email</th><td>{invoice_data['project_details']['client_email']}</td></tr>
                <tr><th>Phone</th><td>{invoice_data['project_details']['client_phone'] or 'N/A'}</td></tr>
            </table>

            <h3>Project Information</h3>
            <table>
                <tr><th>Project No</th><td>{invoice_data['project_details']['project_no']}</td></tr>
                <tr><th>Project Name</th><td>{invoice_data['project_details']['project_name']}</td></tr>
                <tr><th>Location</th><td>{invoice_data['project_details']['location']}</td></tr>
            </table>

            <h3>Invoice Items</h3>
            <table>
                <tr>
                    <th>#</th>
                    <th>Description</th>
                    <th>Test Standard</th>
                    <th class="right">Unit Rate</th>
                    <th class="center">Qty</th>
                    <th class="right">Amount</th>
                    <th>Sample No</th>
                    <th>Status</th>
                </tr>
        """

        # Add item rows
        for i, item in enumerate(invoice_data["items"], 1):
            html_content += f"""
                <tr>
                    <td>{i}</td>
                    <td>{item['description']}</td>
                    <td>{item['test_standard'] or 'N/A'}</td>
                    <td class="right">AED {item['unit_rate']:.2f}</td>
                    <td class="center">{item['quantity']}</td>
                    <td class="right">AED {item['amount']:.2f}</td>
                    <td>{item['sample_no'] or 'N/A'}</td>
                    <td>{item['sample_status']}</td>
                </tr>
            """

        # Financial summary
        html_content += f"""
            </table>

            <h3>Financial Summary</h3>
            <table>
                <tr><th>Subtotal</th><td class="right">AED {invoice_data['subtotal']:.2f}</td></tr>
                <tr><th>VAT (5%)</th><td class="right">AED {invoice_data['vat']:.2f}</td></tr>
                <tr><th>Total</th><td class="right"><b>AED {invoice_data['total']:.2f}</b></td></tr>
                <tr><th>Amount in Words</th><td>{invoice_data['amount_in_words']}</td></tr>
            </table>
        </body>
        </html>
        """

        return HTMLResponse(content=html_content)

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()








# INVOICES 
@router.get("/{invoice_id}/excel")
def generate_excel_invoice(invoice_id: int):
    """
    Generate Excel invoice using the template, insert rows dynamically,
    fill test items, report numbers, amounts, totals and save on server.
    """

    # Path to converted template (.xlsx)
    template_path = r"C:\Users\USER\my-react-app\public\templates\invoice.xlsx"

    if not os.path.exists(template_path):
        raise HTTPException(status_code=404, detail="Invoice template not found. Convert invoice.xls ‚Üí .xlsx")

    conn = get_connection()
    cur = conn.cursor()

    try:
        # =====================================================
        # 1. Load full invoice from DB
        # =====================================================
        invoice = get_invoice_complete(invoice_id, cur)
        project_details = invoice.get("project_details", {})
        
        # Get invoice type to determine if we should filter by reports
        invoice_type = invoice.get("invoice_type", "CASH")
        
        # =====================================================
        # NEW: Filter items for PROFORMA/TAX invoices
        # =====================================================
        if invoice_type in ["PROFORMA", "TAX"]:
            print(f"DEBUG: Filtering items for {invoice_type} invoice {invoice_id}")
            
            # Get reports linked to this invoice
            cur.execute("""
                SELECT report_no 
                FROM invoice_report_links 
                WHERE invoice_id = %s 
                AND invoice_type = %s
            """, (invoice_id, invoice_type))
            
            linked_reports = [row[0] for row in cur.fetchall()]
            print(f"DEBUG: Found {len(linked_reports)} linked reports: {linked_reports}")
            
            # Filter invoice items to only include those with linked reports
            original_items = invoice.get("items", [])
            filtered_items = []
            
            if linked_reports:
                # For each report, find matching invoice items
                for report_no in linked_reports:
                    # Get test type from report
                    cur.execute("""
                        SELECT covers_test_type 
                        FROM reports 
                        WHERE report_no = %s
                    """, (report_no,))
                    
                    report_data = cur.fetchone()
                    if report_data:
                        test_type = report_data[0]
                        print(f"DEBUG: Report {report_no} covers test type: '{test_type}'")
                        
                        # Find invoice items that match this test type
                        for item in original_items:
                            if item.get("description") == test_type:
                                filtered_items.append(item)
                                print(f"DEBUG: Added item '{item.get('description')}' for report {report_no}")
                                break  # Only add one item per report
            else:
                # No linked reports, use all items
                filtered_items = original_items
                print("DEBUG: No linked reports found, using all items")
            
            # Update invoice items with filtered list
            invoice["items"] = filtered_items
            print(f"DEBUG: Filtered from {len(original_items)} to {len(filtered_items)} items")
            
            # =====================================================
            # FIX: RECALCULATE TOTALS based on filtered items only
            # =====================================================
            # Calculate new totals from filtered items
            filtered_subtotal = sum(item.get("amount", 0) for item in filtered_items)
            filtered_vat = filtered_subtotal * 0.05  # 5% VAT
            filtered_total = filtered_subtotal + filtered_vat
            filtered_amount_words = number_to_words(filtered_total)
            
            # Update invoice totals with filtered amounts
            invoice["subtotal"] = filtered_subtotal
            invoice["vat"] = filtered_vat
            invoice["total"] = filtered_total
            invoice["amount_in_words"] = filtered_amount_words
            
            print(f"DEBUG: Recalculated totals for filtered items:")
            print(f"  Subtotal: {filtered_subtotal} (was {invoice.get('subtotal', 'original')})")
            print(f"  VAT: {filtered_vat} (was {invoice.get('vat', 'original')})")
            print(f"  Total: {filtered_total} (was {invoice.get('total', 'original')})")
            
        else:
            # For CASH/CREDIT invoices, use all items and original totals
            invoice["items"] = invoice.get("items", [])
            print("DEBUG: Using original totals for CASH/CREDIT invoice")
        
        items = invoice.get("items", [])
        
        # DEBUG: Print what data we're getting
        print("=== DEBUG INVOICE DATA ===")
        print(f"Invoice: {invoice.get('invoice_no')} (Type: {invoice_type})")
        print(f"Subtotal: {invoice.get('subtotal')}")
        print(f"VAT (5%): {invoice.get('vat')}")
        print(f"Total: {invoice.get('total')}")
        print(f"Number of items after filtering: {len(items)}")
        for i, item in enumerate(items):
            print(f"  Item {i}: Sample {item.get('sample_id')} - {item.get('description')} - Qty: {item.get('quantity')}")
        print("==========================")

        # =====================================================
        # 2. Load the Excel template
        # =====================================================
        wb = openpyxl.load_workbook(template_path, data_only=False)
        ws = wb.active

                # =====================================================
        # NEW: Set title in cell A3 based on invoice type
        # =====================================================
        title_text = ""
        if invoice_type == "PROFORMA":
            title_text = "PROFORMA INVOICE"
        elif invoice_type == "TAX":
            title_text = "TAX INVOICE"
        elif invoice_type == "CASH":
            title_text = "CASH INVOICE"
        elif invoice_type == "CREDIT":
            title_text = "CREDIT INVOICE"
        else:
            title_text = "INVOICE"  # Default
        
        # Set the title text in cell A3
        ws["A3"] = title_text
        
        # Apply formatting: Size 12, Arial, Dark Blue color
        from openpyxl.styles import Font
        
        # Create dark blue color (RGB: 0, 0, 139)
        dark_blue_color = "00008B"  # Hex code for dark blue
        
        # Apply font formatting
        ws["A3"].font = Font(
            name="Arial",
            size=12,
            bold=True,  # Usually titles are bold
            color=dark_blue_color  # Dark blue text
        )
        
        # Optional: Center align the title horizontally
        from openpyxl.styles import Alignment
        ws["A3"].alignment = Alignment(horizontal="center")

        # =====================================================
        # 3. Define Template Structure
        # =====================================================
        FIRST_ITEM_ROW = 18  # First item row in template (based on your image)
        LAST_TEMPLATE_ITEM_ROW = 34  # Last available item row in template
        TOTAL_ROW = 35  # Row with "GRAND TOTAL"
        VAT_ROW = 36    # Row with "VAT @ 5%"
        NET_TOTAL_ROW = 37  # Row with "NET TOTAL"
        AMOUNT_WORDS_ROW = 38  # Row with "United Arab Emirates Dirhams Only"
        
        # Calculate available template rows for items
        TEMPLATE_ITEM_ROWS = LAST_TEMPLATE_ITEM_ROW - FIRST_ITEM_ROW + 1  # 17 rows

        # =====================================================
        # 4. Fill Header Fields - WITH PAYMENT TERMS UPDATE
        # =====================================================
        ws["I4"] = invoice.get("invoice_no", " - ")
        
        # Invoice date
        invoice_date = invoice.get("invoice_date")
        if invoice_date:
            if isinstance(invoice_date, str):
                ws["I5"] = invoice_date
            else:
                ws["I5"] = invoice_date.strftime("%d-%b-%Y")
        else:
            ws["I5"] = " - "

        # Client Section
        ws["A5"] = project_details.get("client_name", " - ")
        ws["C10"] = project_details.get("client_contact", " - ")

        # Project details
        ws["C13"] = project_details.get("project_no", " - ")
        ws["C15"] = project_details.get("project_name", " - ")
        ws["C14"] = project_details.get("location", " - ")

        # LPO
        lpo_reference = invoice.get("lpo_reference", " - ")
        ws["C18"] = lpo_reference
        
        # LPO date
        lpo_date = invoice.get("lpo_date")
        if lpo_date:
            if isinstance(lpo_date, str):
                ws["I6"] = lpo_date
            else:
                ws["I6"] = lpo_date.strftime("%d-%b-%Y")
        else:
            ws["I6"] = " - "

        # Payment Terms - Show CASH or CREDIT based on invoice_type
        invoice_type = invoice.get("invoice_type", "CASH")
        if invoice_type == "CASH":
            payment_display = "CASH / Immediate"
        else:
            payment_display = "CREDIT / 30 days"
            
        ws["I8"] = payment_display

        # =====================================================
        # 5. Handle Dynamic Item Rows - FIXED LOGIC
        # =====================================================
        # We'll determine this after we process items
        # Clear all existing item rows first
        for row in range(FIRST_ITEM_ROW, LAST_TEMPLATE_ITEM_ROW + 1):
            for col in ['A', 'B', 'D', 'E', 'I', 'J', 'K']:
                ws[f"{col}{row}"].value = None

        # =====================================================
        # 6. CORRECTED: Get reports by TEST TYPE not just by sample
        # =====================================================
        print("=== GETTING REPORTS GROUPED BY TEST TYPE ===")

        # FIRST: Get all reports that are linked to this specific invoice
        cur.execute("""
            SELECT report_no 
            FROM invoice_report_links 
            WHERE invoice_id = %s
        """, (invoice_id,))

        linked_report_nos = [row[0] for row in cur.fetchall()]
        print(f"DEBUG: Invoice {invoice_id} has {len(linked_report_nos)} linked reports: {linked_report_nos}")

        if linked_report_nos:
            # This invoice has linked reports (PROFORMA/TAX invoice with selected reports)
            # ONLY fetch the linked reports
            cur.execute("""
                SELECT 
                    r.report_no,
                    r.created_at,
                    r.covers_test_type,
                    r.sample_id,
                    COUNT(DISTINCT s.sample_id) as sample_count
                FROM reports r
                LEFT JOIN samples s ON (
                    r.sample_id = s.sample_id 
                    OR 
                    (r.covers_samples IS NOT NULL AND s.sample_id::text = ANY(r.covers_samples))
                )
                LEFT JOIN test_requests tr ON s.request_id = tr.test_request_id
                WHERE r.report_no = ANY(%s)
                AND r.status = 'APPROVED'
                GROUP BY r.report_no, r.created_at, r.covers_test_type, r.sample_id
                ORDER BY r.report_no
            """, (linked_report_nos,))
        else:
            # This invoice has no linked reports (regular CASH/CREDIT invoice)
            # Get all approved reports for the project
            cur.execute("""
                SELECT 
                    r.report_no,
                    r.created_at,
                    r.covers_test_type,
                    r.sample_id,
                    COUNT(DISTINCT s.sample_id) as sample_count
                FROM reports r
                LEFT JOIN samples s ON (
                    r.sample_id = s.sample_id 
                    OR 
                    (r.covers_samples IS NOT NULL AND s.sample_id::text = ANY(r.covers_samples))
                )
                LEFT JOIN test_requests tr ON s.request_id = tr.test_request_id
                WHERE tr.project_id = %s
                AND r.status = 'APPROVED'
                GROUP BY r.report_no, r.created_at, r.covers_test_type, r.sample_id
                ORDER BY r.report_no
            """, (invoice.get("project_id"),))

        all_reports = cur.fetchall()
        
        print(f"Found {len(all_reports)} approved reports for project")
        
        # Create mapping: test_type -> list of reports
        test_type_to_reports = {}
        for report in all_reports:
            report_no, created_at, test_type, sample_id, sample_count = report
            if test_type:
                if test_type not in test_type_to_reports:
                    test_type_to_reports[test_type] = []
                test_type_to_reports[test_type].append({
                    "report_no": report_no,
                    "created_at": created_at,
                    "sample_id": sample_id,
                    "sample_count": sample_count
                })
                print(f"Report {report_no}: Test Type = '{test_type}', Sample ID = {sample_id}, Covers {sample_count} samples")

        print("\n=== TEST TYPE TO REPORTS MAPPING ===")
        for test_type, reports in test_type_to_reports.items():
            print(f"Test Type: '{test_type}' has {len(reports)} reports:")
            for report in reports:
                print(f"  - {report['report_no']}")
        print("====================================\n")

        # =====================================================
        # 7. Match invoice items to reports by TEST TYPE
        # =====================================================
        print("=== MATCHING INVOICE ITEMS TO REPORTS ===")
        
        matched_items = []
        unmatched_items = []
        
        for index, item in enumerate(items):
            sample_id = item.get("sample_id")
            description = item.get("description", " - ")
            test_standard = item.get("test_standard", " - ")
            unit_rate = float(item.get("unit_rate", 0))
            quantity = int(item.get("quantity", 0))
            amount = float(item.get("amount", 0))
            
            print(f"\nProcessing invoice item {index}:")
            print(f"  Sample: {sample_id}")
            print(f"  Description: '{description}'")
            print(f"  Test Standard: '{test_standard}'")
            
            # Try to find a report for this test type
            matched_report = None
            
            # First: Check if we have any reports for this exact test type
            if description in test_type_to_reports and test_type_to_reports[description]:
                # Use the first report for this test type
                report_info = test_type_to_reports[description][0]
                matched_report = {
                    "report_no": report_info["report_no"],
                    "created_at": report_info["created_at"],
                    "test_type": description
                }
                print(f"  ‚úì Found report by test type: {report_info['report_no']}")
                
                # Remove this report from available list so we don't reuse it
                test_type_to_reports[description].pop(0)
                
            # Second: Try fuzzy match if exact match not found
            if not matched_report:
                for test_type, reports in test_type_to_reports.items():
                    if reports and (test_type in description or description in test_type):
                        report_info = reports[0]
                        matched_report = {
                            "report_no": report_info["report_no"],
                            "created_at": report_info["created_at"],
                            "test_type": test_type
                        }
                        print(f"  ‚âà Found report by fuzzy match: {report_info['report_no']} (Test: '{test_type}' matches '{description}')")
                        reports.pop(0)
                        break
            
            # Third: If still no match, create a placeholder
            if not matched_report:
                print(f"  ‚úó No report found for test type '{description}'")
                matched_report = {
                    "report_no": f"INV-{invoice.get('invoice_no')}-{index+1}",
                    "created_at": None,
                    "test_type": description
                }
                unmatched_items.append(item)
            
            # Format date
            if matched_report["created_at"]:
                report_date = matched_report["created_at"].strftime("%d-%b-%Y") if hasattr(matched_report["created_at"], 'strftime') else str(matched_report["created_at"])
            else:
                report_date = " - "
            
            matched_items.append({
                "report_no": matched_report["report_no"],
                "report_date": report_date,
                "description": matched_report["test_type"],  # Use report's test type
                "test_standard": test_standard,
                "unit_rate": unit_rate,
                "quantity": quantity,
                "amount": amount,
                "sample_id": sample_id,
                "original_description": description  # Keep original for reference
            })
        
        # =====================================================
        # 8. GROUP by report number (combine same reports)
        # =====================================================
        print("\n=== GROUPING BY REPORT NUMBER ===")
        
        report_grouping = {}
        for item in matched_items:
            report_no = item["report_no"]
            
            if report_no not in report_grouping:
                report_grouping[report_no] = {
                    "report_no": report_no,
                    "report_date": item["report_date"],
                    "description": item["description"],
                    "test_standard": item["test_standard"],
                    "unit_rate": item["unit_rate"],
                    "total_quantity": 0,
                    "total_amount": 0.0,
                    "samples": [],
                    "sample_count": 0
                }
            
            # Accumulate quantities and amounts
            report_grouping[report_no]["total_quantity"] += item["quantity"]
            report_grouping[report_no]["total_amount"] += item["amount"]
            report_grouping[report_no]["samples"].append(item["sample_id"])
            report_grouping[report_no]["sample_count"] += 1
        
        # Convert to list
        grouped_items = list(report_grouping.values())
        
        print(f"Created {len(grouped_items)} grouped items from {len(matched_items)} invoice items")
        for i, item in enumerate(grouped_items):
            print(f"Group {i+1}: {item['report_no']} - {item['description']} - Qty: {item['total_quantity']} - Amount: AED {item['total_amount']}")

        # =====================================================
        # 9. Determine if we need extra rows
        # =====================================================
        num_items_to_display = len(grouped_items)

        # Calculate where items will actually go
        if num_items_to_display <= TEMPLATE_ITEM_ROWS:
            # Case 1: Items fit within template rows
            last_item_row = FIRST_ITEM_ROW + num_items_to_display - 1
        else:
            # Case 2: Need more rows than template provides
            rows_needed = num_items_to_display - TEMPLATE_ITEM_ROWS
            
            # Insert rows AFTER the template item area (after row 34)
            ws.insert_rows(LAST_TEMPLATE_ITEM_ROW + 1, amount=rows_needed)
            
            # Copy formatting from last template row (row 34) to new rows
            from copy import copy
            for i in range(rows_needed):
                new_row = LAST_TEMPLATE_ITEM_ROW + 1 + i
                # Copy formatting from row 34
                for col in range(1, 12):  # Columns A-K
                    source_cell = ws.cell(row=34, column=col)
                    target_cell = ws.cell(row=new_row, column=col)
                    target_cell.font = copy(source_cell.font)
                    target_cell.border = copy(source_cell.border)
                    target_cell.fill = copy(source_cell.fill)
                    target_cell.number_format = source_cell.number_format
                    target_cell.alignment = copy(source_cell.alignment)
            
            last_item_row = LAST_TEMPLATE_ITEM_ROW + rows_needed

        # =====================================================
        # 10. Fill rows with matched data
        # =====================================================
        print("\n=== FILLING EXCEL ROWS ===")
        for index, item in enumerate(grouped_items):
            # Determine which row to use
            if index < TEMPLATE_ITEM_ROWS:
                # Use template rows (18-34)
                row = FIRST_ITEM_ROW + index
            else:
                # Use newly inserted rows
                extra_index = index - TEMPLATE_ITEM_ROWS
                row = LAST_TEMPLATE_ITEM_ROW + 1 + extra_index

            # Fill columns A‚ÄìK
            ws[f"A{row}"] = item["report_no"]
            ws[f"B{row}"] = item["report_date"]
            ws[f"D{row}"] = item["description"]
            ws[f"E{row}"] = item["test_standard"]
            ws[f"I{row}"] = item["total_quantity"]
            ws[f"J{row}"] = item["unit_rate"]
            ws[f"K{row}"] = item["total_amount"]
            
            print(f"Row {row}: {item['report_no']} - {item['description']} x{item['total_quantity']} = AED {item['total_amount']}")

        # =====================================================
        # 11. UPDATE FORMULAS - FIXED
        # =====================================================
        print(f"\n=== UPDATING EXCEL FORMULAS ===")
        print(f"First item row: {FIRST_ITEM_ROW}")
        print(f"Last item row: {last_item_row}")
        print(f"Items displayed: {num_items_to_display}")
        
        # IMPORTANT: Update the SUM formula to cover ALL item rows
        ws["K35"].value = f"=SUM(K{FIRST_ITEM_ROW}:K{last_item_row})"
        
        # K36 FORMULA: 5% of subtotal
        ws["K36"].value = "=K35*0.05"
        
        # K37 FORMULA: Subtotal + VAT
        ws["K37"].value = "=K35+K36"
        
        # Amount in words - USE THE RECALCULATED VALUE for PROFORMA/TAX invoices
        ws["B38"] = invoice.get("amount_in_words", " - ")
        
        print(f"K35 formula: =SUM(K{FIRST_ITEM_ROW}:K{last_item_row})")
        print(f"K36 formula: {ws['K36'].value}")
        print(f"K37 formula: {ws['K37'].value}")
        print(f"B38 amount in words: {invoice.get('amount_in_words', ' - ')}")
        
        # =====================================================
        # 12. Verify calculations match database
        # =====================================================
        # Calculate what Excel should show
        excel_subtotal = sum(item.get("total_amount", 0) for item in grouped_items)
        excel_vat = excel_subtotal * 0.05
        excel_total = excel_subtotal + excel_vat
        
        # Use the invoice totals (which are now recalculated for PROFORMA/TAX invoices)
        db_subtotal = float(invoice.get("subtotal", 0))
        db_vat = float(invoice.get("vat", 0))
        db_total = float(invoice.get("total", 0))
        
        print(f"\n=== VERIFICATION ===")
        print(f"Database values -> Subtotal: {db_subtotal}, VAT: {db_vat}, Total: {db_total}")
        print(f"Excel will show -> Subtotal: {excel_subtotal}, VAT: {excel_vat}, Total: {excel_total}")
        
        # Check if they match
        if abs(db_subtotal - excel_subtotal) > 0.01:
            print(f"WARNING: Subtotal mismatch! Database: {db_subtotal}, Excel: {excel_subtotal}")
        
        if abs(db_total - excel_total) > 0.01:
            print(f"WARNING: Total mismatch! Database: {db_total}, Excel: {excel_total}")

        # =====================================================
        # 13. Save Final File on Server
        # =====================================================
        output_dir = r"C:\Users\USER\my-react-app\public\generated_invoices"
        os.makedirs(output_dir, exist_ok=True)

        # Create download filename
        invoice_no = invoice.get('invoice_no', 'invoice')
        project_name = project_details.get('project_name', '')
        lpo_reference = invoice.get("lpo_reference", "")
        
        # Replace slash with hyphen in invoice number for filename
        invoice_no_hyphen = invoice_no.replace('/', '-')
        
        # Clean up strings for filename
        import re
        
        def clean_filename(text):
            if not text:
                return ""
            text = re.sub(r'[\\/*?:"<>|]', '-', text)
            text = re.sub(r'\s+', '-', text)
            text = text.strip('- ')
            return text
        
        clean_project_name = clean_filename(project_name)
        
        has_lpo = lpo_reference and lpo_reference != " - " and lpo_reference != ""
        
        if has_lpo:
            clean_lpo_number = clean_filename(str(lpo_reference))
            download_filename = f"{invoice_no_hyphen}-{clean_project_name}-{clean_lpo_number}.xlsx"
        else:
            download_filename = f"{invoice_no_hyphen}-{clean_project_name}.xlsx"
        
        # Save file
        output_path = os.path.join(output_dir, f"{invoice_no_hyphen}.xlsx")
        wb.save(output_path)

        # =====================================================
        # 14. Return File for Download
        # =====================================================
        import urllib.parse
        encoded_filename = urllib.parse.quote(download_filename)
        
        return FileResponse(
            output_path,
            filename=download_filename,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f"attachment; filename*=UTF-8''{encoded_filename}; filename=\"{download_filename}\""
            }
        )

    except Exception as e:
        print("Error generating invoice:", e)
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        cur.close()
        conn.close()
    """
    Generate Excel invoice using the template, insert rows dynamically,
    fill test items, report numbers, amounts, totals and save on server.
    """

    # Path to converted template (.xlsx)
    template_path = r"C:\Users\USER\my-react-app\public\templates\invoice.xlsx"

    if not os.path.exists(template_path):
        raise HTTPException(status_code=404, detail="Invoice template not found. Convert invoice.xls ‚Üí .xlsx")

    conn = get_connection()
    cur = conn.cursor()

    try:
        # =====================================================
        # 1. Load full invoice from DB
        # =====================================================
        invoice = get_invoice_complete(invoice_id, cur)
        project_details = invoice.get("project_details", {})
        
        # Get invoice type to determine if we should filter by reports
        invoice_type = invoice.get("invoice_type", "CASH")
        
        # =====================================================
        # NEW: Filter items for PROFORMA/TAX invoices
        # =====================================================
        if invoice_type in ["PROFORMA", "TAX"]:
            print(f"DEBUG: Filtering items for {invoice_type} invoice {invoice_id}")
            
            # Get reports linked to this invoice
            cur.execute("""
                SELECT report_no 
                FROM invoice_report_links 
                WHERE invoice_id = %s 
                AND invoice_type = %s
            """, (invoice_id, invoice_type))
            
            linked_reports = [row[0] for row in cur.fetchall()]
            print(f"DEBUG: Found {len(linked_reports)} linked reports: {linked_reports}")
            
            # Filter invoice items to only include those with linked reports
            original_items = invoice.get("items", [])
            filtered_items = []
            
            if linked_reports:
                # For each report, find matching invoice items
                for report_no in linked_reports:
                    # Get test type from report
                    cur.execute("""
                        SELECT covers_test_type 
                        FROM reports 
                        WHERE report_no = %s
                    """, (report_no,))
                    
                    report_data = cur.fetchone()
                    if report_data:
                        test_type = report_data[0]
                        print(f"DEBUG: Report {report_no} covers test type: '{test_type}'")
                        
                        # Find invoice items that match this test type
                        for item in original_items:
                            if item.get("description") == test_type:
                                filtered_items.append(item)
                                print(f"DEBUG: Added item '{item.get('description')}' for report {report_no}")
                                break  # Only add one item per report
            else:
                # No linked reports, use all items
                filtered_items = original_items
                print("DEBUG: No linked reports found, using all items")
            
            # Update invoice items with filtered list
            invoice["items"] = filtered_items
            print(f"DEBUG: Filtered from {len(original_items)} to {len(filtered_items)} items")
        else:
            # For CASH/CREDIT invoices, use all items
            invoice["items"] = invoice.get("items", [])
        
        items = invoice.get("items", [])
        
        # DEBUG: Print what data we're getting
        print("=== DEBUG INVOICE DATA ===")
        print(f"Invoice: {invoice.get('invoice_no')} (Type: {invoice_type})")
        print(f"Subtotal: {invoice.get('subtotal')}")
        print(f"VAT (5%): {invoice.get('vat')}")
        print(f"Total: {invoice.get('total')}")
        print(f"Number of items after filtering: {len(items)}")
        for i, item in enumerate(items):
            print(f"  Item {i}: Sample {item.get('sample_id')} - {item.get('description')} - Qty: {item.get('quantity')}")
        print("==========================")

        # =====================================================
        # 2. Load the Excel template
        # =====================================================
        wb = openpyxl.load_workbook(template_path, data_only=False)
        ws = wb.active

                # =====================================================
        # NEW: Set title in cell A3 based on invoice type
        # =====================================================
        title_text = ""
        if invoice_type == "PROFORMA":
            title_text = "PROFORMA INVOICE"
        elif invoice_type == "TAX":
            title_text = "TAX INVOICE"
        elif invoice_type == "CASH":
            title_text = "CASH INVOICE"
        elif invoice_type == "CREDIT":
            title_text = "CREDIT INVOICE"
        else:
            title_text = "INVOICE"  # Default
        
        # Set the title text in cell A3
        ws["A3"] = title_text
        
        # Apply formatting: Size 12, Arial, Dark Blue color
        from openpyxl.styles import Font
        
        # Create dark blue color (RGB: 0, 0, 139)
        dark_blue_color = "00008B"  # Hex code for dark blue
        
        # Apply font formatting
        ws["A3"].font = Font(
            name="Arial",
            size=12,
            bold=True,  # Usually titles are bold
            color=dark_blue_color  # Dark blue text
        )
        
        # Optional: Center align the title horizontally
        from openpyxl.styles import Alignment
        ws["A3"].alignment = Alignment(horizontal="center")

        # =====================================================
        # 3. Define Template Structure
        # =====================================================
        FIRST_ITEM_ROW = 18  # First item row in template (based on your image)
        LAST_TEMPLATE_ITEM_ROW = 34  # Last available item row in template
        TOTAL_ROW = 35  # Row with "GRAND TOTAL"
        VAT_ROW = 36    # Row with "VAT @ 5%"
        NET_TOTAL_ROW = 37  # Row with "NET TOTAL"
        AMOUNT_WORDS_ROW = 38  # Row with "United Arab Emirates Dirhams Only"
        
        # Calculate available template rows for items
        TEMPLATE_ITEM_ROWS = LAST_TEMPLATE_ITEM_ROW - FIRST_ITEM_ROW + 1  # 17 rows

        # =====================================================
        # 4. Fill Header Fields - WITH PAYMENT TERMS UPDATE
        # =====================================================
        ws["I4"] = invoice.get("invoice_no", " - ")
        
        # Invoice date
        invoice_date = invoice.get("invoice_date")
        if invoice_date:
            if isinstance(invoice_date, str):
                ws["I5"] = invoice_date
            else:
                ws["I5"] = invoice_date.strftime("%d-%b-%Y")
        else:
            ws["I5"] = " - "

        # Client Section
        ws["A5"] = project_details.get("client_name", " - ")
        ws["C10"] = project_details.get("client_contact", " - ")

        # Project details
        ws["C13"] = project_details.get("project_no", " - ")
        ws["C15"] = project_details.get("project_name", " - ")
        ws["C14"] = project_details.get("location", " - ")

        # LPO
        lpo_reference = invoice.get("lpo_reference", " - ")
        ws["C18"] = lpo_reference
        
        # LPO date
        lpo_date = invoice.get("lpo_date")
        if lpo_date:
            if isinstance(lpo_date, str):
                ws["I6"] = lpo_date
            else:
                ws["I6"] = lpo_date.strftime("%d-%b-%Y")
        else:
            ws["I6"] = " - "

        # Payment Terms - Show CASH or CREDIT based on invoice_type
        invoice_type = invoice.get("invoice_type", "CASH")
        if invoice_type == "CASH":
            payment_display = "CASH / Immediate"
        else:
            payment_display = "CREDIT / 30 days"
            
        ws["I8"] = payment_display

        # =====================================================
        # 5. Handle Dynamic Item Rows - FIXED LOGIC
        # =====================================================
        # We'll determine this after we process items
        # Clear all existing item rows first
        for row in range(FIRST_ITEM_ROW, LAST_TEMPLATE_ITEM_ROW + 1):
            for col in ['A', 'B', 'D', 'E', 'I', 'J', 'K']:
                ws[f"{col}{row}"].value = None

        # =====================================================
        # 6. CORRECTED: Get reports by TEST TYPE not just by sample
        # =====================================================
        print("=== GETTING REPORTS GROUPED BY TEST TYPE ===")

        # FIRST: Get all reports that are linked to this specific invoice
        cur.execute("""
            SELECT report_no 
            FROM invoice_report_links 
            WHERE invoice_id = %s
        """, (invoice_id,))

        linked_report_nos = [row[0] for row in cur.fetchall()]
        print(f"DEBUG: Invoice {invoice_id} has {len(linked_report_nos)} linked reports: {linked_report_nos}")

        if linked_report_nos:
            # This invoice has linked reports (PROFORMA/TAX invoice with selected reports)
            # ONLY fetch the linked reports
            cur.execute("""
                SELECT 
                    r.report_no,
                    r.created_at,
                    r.covers_test_type,
                    r.sample_id,
                    COUNT(DISTINCT s.sample_id) as sample_count
                FROM reports r
                LEFT JOIN samples s ON (
                    r.sample_id = s.sample_id 
                    OR 
                    (r.covers_samples IS NOT NULL AND s.sample_id::text = ANY(r.covers_samples))
                )
                LEFT JOIN test_requests tr ON s.request_id = tr.test_request_id
                WHERE r.report_no = ANY(%s)
                AND r.status = 'APPROVED'
                GROUP BY r.report_no, r.created_at, r.covers_test_type, r.sample_id
                ORDER BY r.report_no
            """, (linked_report_nos,))
        else:
            # This invoice has no linked reports (regular CASH/CREDIT invoice)
            # Get all approved reports for the project
            cur.execute("""
                SELECT 
                    r.report_no,
                    r.created_at,
                    r.covers_test_type,
                    r.sample_id,
                    COUNT(DISTINCT s.sample_id) as sample_count
                FROM reports r
                LEFT JOIN samples s ON (
                    r.sample_id = s.sample_id 
                    OR 
                    (r.covers_samples IS NOT NULL AND s.sample_id::text = ANY(r.covers_samples))
                )
                LEFT JOIN test_requests tr ON s.request_id = tr.test_request_id
                WHERE tr.project_id = %s
                AND r.status = 'APPROVED'
                GROUP BY r.report_no, r.created_at, r.covers_test_type, r.sample_id
                ORDER BY r.report_no
            """, (invoice.get("project_id"),))

        all_reports = cur.fetchall()
        
        print(f"Found {len(all_reports)} approved reports for project")
        
        # Create mapping: test_type -> list of reports
        test_type_to_reports = {}
        for report in all_reports:
            report_no, created_at, test_type, sample_id, sample_count = report
            if test_type:
                if test_type not in test_type_to_reports:
                    test_type_to_reports[test_type] = []
                test_type_to_reports[test_type].append({
                    "report_no": report_no,
                    "created_at": created_at,
                    "sample_id": sample_id,
                    "sample_count": sample_count
                })
                print(f"Report {report_no}: Test Type = '{test_type}', Sample ID = {sample_id}, Covers {sample_count} samples")

        print("\n=== TEST TYPE TO REPORTS MAPPING ===")
        for test_type, reports in test_type_to_reports.items():
            print(f"Test Type: '{test_type}' has {len(reports)} reports:")
            for report in reports:
                print(f"  - {report['report_no']}")
        print("====================================\n")

        # =====================================================
        # 7. Match invoice items to reports by TEST TYPE
        # =====================================================
        print("=== MATCHING INVOICE ITEMS TO REPORTS ===")
        
        matched_items = []
        unmatched_items = []
        
        for index, item in enumerate(items):
            sample_id = item.get("sample_id")
            description = item.get("description", " - ")
            test_standard = item.get("test_standard", " - ")
            unit_rate = float(item.get("unit_rate", 0))
            quantity = int(item.get("quantity", 0))
            amount = float(item.get("amount", 0))
            
            print(f"\nProcessing invoice item {index}:")
            print(f"  Sample: {sample_id}")
            print(f"  Description: '{description}'")
            print(f"  Test Standard: '{test_standard}'")
            
            # Try to find a report for this test type
            matched_report = None
            
            # First: Check if we have any reports for this exact test type
            if description in test_type_to_reports and test_type_to_reports[description]:
                # Use the first report for this test type
                report_info = test_type_to_reports[description][0]
                matched_report = {
                    "report_no": report_info["report_no"],
                    "created_at": report_info["created_at"],
                    "test_type": description
                }
                print(f"  ‚úì Found report by test type: {report_info['report_no']}")
                
                # Remove this report from available list so we don't reuse it
                test_type_to_reports[description].pop(0)
                
            # Second: Try fuzzy match if exact match not found
            if not matched_report:
                for test_type, reports in test_type_to_reports.items():
                    if reports and (test_type in description or description in test_type):
                        report_info = reports[0]
                        matched_report = {
                            "report_no": report_info["report_no"],
                            "created_at": report_info["created_at"],
                            "test_type": test_type
                        }
                        print(f"  ‚âà Found report by fuzzy match: {report_info['report_no']} (Test: '{test_type}' matches '{description}')")
                        reports.pop(0)
                        break
            
            # Third: If still no match, create a placeholder
            if not matched_report:
                print(f"  ‚úó No report found for test type '{description}'")
                matched_report = {
                    "report_no": f"INV-{invoice.get('invoice_no')}-{index+1}",
                    "created_at": None,
                    "test_type": description
                }
                unmatched_items.append(item)
            
            # Format date
            if matched_report["created_at"]:
                report_date = matched_report["created_at"].strftime("%d-%b-%Y") if hasattr(matched_report["created_at"], 'strftime') else str(matched_report["created_at"])
            else:
                report_date = " - "
            
            matched_items.append({
                "report_no": matched_report["report_no"],
                "report_date": report_date,
                "description": matched_report["test_type"],  # Use report's test type
                "test_standard": test_standard,
                "unit_rate": unit_rate,
                "quantity": quantity,
                "amount": amount,
                "sample_id": sample_id,
                "original_description": description  # Keep original for reference
            })
        
        # =====================================================
        # 8. GROUP by report number (combine same reports)
        # =====================================================
        print("\n=== GROUPING BY REPORT NUMBER ===")
        
        report_grouping = {}
        for item in matched_items:
            report_no = item["report_no"]
            
            if report_no not in report_grouping:
                report_grouping[report_no] = {
                    "report_no": report_no,
                    "report_date": item["report_date"],
                    "description": item["description"],
                    "test_standard": item["test_standard"],
                    "unit_rate": item["unit_rate"],
                    "total_quantity": 0,
                    "total_amount": 0.0,
                    "samples": [],
                    "sample_count": 0
                }
            
            # Accumulate quantities and amounts
            report_grouping[report_no]["total_quantity"] += item["quantity"]
            report_grouping[report_no]["total_amount"] += item["amount"]
            report_grouping[report_no]["samples"].append(item["sample_id"])
            report_grouping[report_no]["sample_count"] += 1
        
        # Convert to list
        grouped_items = list(report_grouping.values())
        
        print(f"Created {len(grouped_items)} grouped items from {len(matched_items)} invoice items")
        for i, item in enumerate(grouped_items):
            print(f"Group {i+1}: {item['report_no']} - {item['description']} - Qty: {item['total_quantity']} - Amount: AED {item['total_amount']}")

        # =====================================================
        # 9. Determine if we need extra rows
        # =====================================================
        num_items_to_display = len(grouped_items)

        # Calculate where items will actually go
        if num_items_to_display <= TEMPLATE_ITEM_ROWS:
            # Case 1: Items fit within template rows
            last_item_row = FIRST_ITEM_ROW + num_items_to_display - 1
        else:
            # Case 2: Need more rows than template provides
            rows_needed = num_items_to_display - TEMPLATE_ITEM_ROWS
            
            # Insert rows AFTER the template item area (after row 34)
            ws.insert_rows(LAST_TEMPLATE_ITEM_ROW + 1, amount=rows_needed)
            
            # Copy formatting from last template row (row 34) to new rows
            from copy import copy
            for i in range(rows_needed):
                new_row = LAST_TEMPLATE_ITEM_ROW + 1 + i
                # Copy formatting from row 34
                for col in range(1, 12):  # Columns A-K
                    source_cell = ws.cell(row=34, column=col)
                    target_cell = ws.cell(row=new_row, column=col)
                    target_cell.font = copy(source_cell.font)
                    target_cell.border = copy(source_cell.border)
                    target_cell.fill = copy(source_cell.fill)
                    target_cell.number_format = source_cell.number_format
                    target_cell.alignment = copy(source_cell.alignment)
            
            last_item_row = LAST_TEMPLATE_ITEM_ROW + rows_needed

        # =====================================================
        # 10. Fill rows with matched data
        # =====================================================
        print("\n=== FILLING EXCEL ROWS ===")
        for index, item in enumerate(grouped_items):
            # Determine which row to use
            if index < TEMPLATE_ITEM_ROWS:
                # Use template rows (18-34)
                row = FIRST_ITEM_ROW + index
            else:
                # Use newly inserted rows
                extra_index = index - TEMPLATE_ITEM_ROWS
                row = LAST_TEMPLATE_ITEM_ROW + 1 + extra_index

            # Fill columns A‚ÄìK
            ws[f"A{row}"] = item["report_no"]
            ws[f"B{row}"] = item["report_date"]
            ws[f"D{row}"] = item["description"]
            ws[f"E{row}"] = item["test_standard"]
            ws[f"I{row}"] = item["total_quantity"]
            ws[f"J{row}"] = item["unit_rate"]
            ws[f"K{row}"] = item["total_amount"]
            
            print(f"Row {row}: {item['report_no']} - {item['description']} x{item['total_quantity']} = AED {item['total_amount']}")

        # =====================================================
        # 11. UPDATE FORMULAS - FIXED
        # =====================================================
        print(f"\n=== UPDATING EXCEL FORMULAS ===")
        print(f"First item row: {FIRST_ITEM_ROW}")
        print(f"Last item row: {last_item_row}")
        print(f"Items displayed: {num_items_to_display}")
        
        # IMPORTANT: Update the SUM formula to cover ALL item rows
        ws["K35"].value = f"=SUM(K{FIRST_ITEM_ROW}:K{last_item_row})"
        
        # K36 FORMULA: 5% of subtotal
        ws["K36"].value = "=K35*0.05"
        
        # K37 FORMULA: Subtotal + VAT
        ws["K37"].value = "=K35+K36"
        
        # Amount in words (static value)
        ws["B38"] = invoice.get("amount_in_words", " - ")
        
        print(f"K35 formula: =SUM(K{FIRST_ITEM_ROW}:K{last_item_row})")
        print(f"K36 formula: {ws['K36'].value}")
        print(f"K37 formula: {ws['K37'].value}")
        
        # =====================================================
        # 12. Verify calculations match database
        # =====================================================
        # Calculate what Excel should show
        excel_subtotal = sum(item.get("total_amount", 0) for item in grouped_items)
        excel_vat = excel_subtotal * 0.05
        excel_total = excel_subtotal + excel_vat
        
        db_subtotal = float(invoice.get("subtotal", 0))
        db_vat = float(invoice.get("vat", 0))
        db_total = float(invoice.get("total", 0))
        
        print(f"\n=== VERIFICATION ===")
        print(f"Database values -> Subtotal: {db_subtotal}, VAT: {db_vat}, Total: {db_total}")
        print(f"Excel will show -> Subtotal: {excel_subtotal}, VAT: {excel_vat}, Total: {excel_total}")

        # =====================================================
        # 13. Save Final File on Server
        # =====================================================
        output_dir = r"C:\Users\USER\my-react-app\public\generated_invoices"
        os.makedirs(output_dir, exist_ok=True)

        # Create download filename
        invoice_no = invoice.get('invoice_no', 'invoice')
        project_name = project_details.get('project_name', '')
        lpo_reference = invoice.get("lpo_reference", "")
        
        # Replace slash with hyphen in invoice number for filename
        invoice_no_hyphen = invoice_no.replace('/', '-')
        
        # Clean up strings for filename
        import re
        
        def clean_filename(text):
            if not text:
                return ""
            text = re.sub(r'[\\/*?:"<>|]', '-', text)
            text = re.sub(r'\s+', '-', text)
            text = text.strip('- ')
            return text
        
        clean_project_name = clean_filename(project_name)
        
        has_lpo = lpo_reference and lpo_reference != " - " and lpo_reference != ""
        
        if has_lpo:
            clean_lpo_number = clean_filename(str(lpo_reference))
            download_filename = f"{invoice_no_hyphen}-{clean_project_name}-{clean_lpo_number}.xlsx"
        else:
            download_filename = f"{invoice_no_hyphen}-{clean_project_name}.xlsx"
        
        # Save file
        output_path = os.path.join(output_dir, f"{invoice_no_hyphen}.xlsx")
        wb.save(output_path)

        # =====================================================
        # 14. Return File for Download
        # =====================================================
        import urllib.parse
        encoded_filename = urllib.parse.quote(download_filename)
        
        return FileResponse(
            output_path,
            filename=download_filename,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f"attachment; filename*=UTF-8''{encoded_filename}; filename=\"{download_filename}\""
            }
        )

    except Exception as e:
        print("Error generating invoice:", e)
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        cur.close()
        conn.close()


# ----------------------------
# GET LATEST PROJECTS FOR INVOICE DROPDOWN - ENHANCED VERSION
# ----------------------------
@router.get("/projects/latest/")
def get_latest_projects():
    """
    Get the latest 10 projects with complete info for invoice creation
    Returns: Array of project objects with details
    """
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Enhanced query with more details
        cur.execute("""
            SELECT 
                p.project_id,
                p.project_name,
                p.project_no,
                c.name as client_name,
                p.location,
                q.quotation_no
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            JOIN quotations q ON p.quotation_id = q.quotation_id
            ORDER BY p.project_id DESC
            LIMIT 10
        """)
        
        # Format response
        projects = []
        for row in cur.fetchall():
            project_id, project_name, project_no, client_name, location, quotation_no = row
            
            # Create display label for dropdown
            display_label = f"{project_no} - {project_name} ({client_name})"
            
            projects.append({
                "project_id": project_id,
                "project_name": display_label,  # Combined display text
                "project_no": project_no,
                "project_name_raw": project_name,  # Original project name
                "client_name": client_name,
                "location": location,
                "quotation_no": quotation_no,
                "value": project_id,  # For dropdown value
                "label": display_label  # For dropdown label
            })
        
        return projects
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()



# Add this to your invoices.py file, after the existing endpoints

# ----------------------------
# DELIVERY NOTE GENERATION
# ----------------------------

# Replace the existing DeliveryNoteRequest class with this:
class DeliveryNoteRequest(BaseModel):
    project_id: int
    selected_report_ids: Optional[List[int]] = None
    include_all_reports: bool = True





def generate_delivery_note_number(cur):
    """Generate delivery note number: 13212/25, 13213/25, etc."""
    # Get the last 2 digits of current year
    year_short = str(datetime.now().year)[-2:]
    
    try:
        # Check if delivery_notes table exists
        cur.execute("""
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'delivery_notes'
            )
        """)
        table_exists = cur.fetchone()[0]
        
        if table_exists:
            # Get max delivery note number
            cur.execute("""
                SELECT delivery_note_no FROM delivery_notes 
                ORDER BY delivery_note_id DESC LIMIT 1
            """)
            last_dn = cur.fetchone()
            
            if last_dn and last_dn[0]:
                try:
                    # Extract number from format like "13212/25"
                    last_number = int(last_dn[0].split('/')[0])
                    next_number = last_number + 1
                except:
                    next_number = 13212
            else:
                next_number = 13212
        else:
            # Table doesn't exist, start from 13212
            next_number = 13212
            
    except Exception as e:
        print(f"Error in generate_delivery_note_number: {e}")
        next_number = 13212
    
    return f"{next_number}/{year_short}"




@router.get("/projects/{project_id}/reports-for-delivery")
def get_reports_for_delivery_note(project_id: int):
    """
    Get all approved reports for a project to select for delivery note
    Now includes delivery note status check
    """
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Ensure the junction table exists before querying
        ensure_delivery_note_reports_table(cur)
        
        # Get project details
        cur.execute(""" 
            SELECT p.project_no, p.project_name, c.name as client_name
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            WHERE p.project_id = %s
        """, (project_id,))
        
        project_data = cur.fetchone()
        if not project_data:
            raise HTTPException(status_code=404, detail="Project not found")
        
        project_no, project_name, client_name = project_data
        
        print(f"DEBUG: Fetching reports for project {project_id} - {project_name}")
        
        # Get all approved reports for this project
        # SIMPLIFIED QUERY - Let's first get all reports, then check delivery note status
        cur.execute("""
            SELECT DISTINCT ON (r.report_no)
                r.report_id, 
                r.report_no, 
                r.created_at,
                r.covers_test_type as test_name,
                r.covers_samples,
                -- Count samples in the covers_samples array
                array_length(r.covers_samples, 1) as sample_count
            FROM reports r
            JOIN samples s ON r.sample_id = s.sample_id
            JOIN test_requests tr ON s.request_id = tr.test_request_id
            WHERE tr.project_id = %s 
            AND r.status = 'APPROVED'
            ORDER BY r.report_no, r.created_at DESC
        """, (project_id,))
        
        all_reports = cur.fetchall()
        
        print(f"DEBUG: Found {len(all_reports)} approved reports")
        
        reports = []
        delivered_count = 0
        undelivered_count = 0
        
        for row in all_reports:
            report_id = row[0]
            report_no = row[1]
            created_date = row[2]
            test_name = row[3]
            covers_samples = row[4]
            sample_count = row[5] or 0
            
            # Check if this report is already in delivery_note_reports
            cur.execute("""
                SELECT 1 FROM delivery_note_reports 
                WHERE report_no = %s
                LIMIT 1
            """, (report_no,))
            
            already_in_delivery_note = cur.fetchone() is not None
            
            # Get the actual sample numbers from the array if available
            sample_nos = []
            if covers_samples and len(covers_samples) > 0:
                # Join with samples table to get sample numbers
                placeholders = ','.join(['%s'] * len(covers_samples))
                cur.execute(f"""
                    SELECT sample_no FROM samples 
                    WHERE sample_no IN ({placeholders})
                """, tuple(covers_samples))
                sample_rows = cur.fetchall()
                sample_nos = [row[0] for row in sample_rows] if sample_rows else []
            else:
                # Fallback: get the sample_no for this specific report
                cur.execute("""
                    SELECT s.sample_no FROM samples s
                    WHERE s.sample_id = (
                        SELECT sample_id FROM reports 
                        WHERE report_no = %s LIMIT 1
                    )
                """, (report_no,))
                sample_row = cur.fetchone()
                if sample_row:
                    sample_nos = [sample_row[0]]
                    sample_count = 1
            
            if already_in_delivery_note:
                delivered_count += 1
                print(f"DEBUG: Report {report_no} is already in delivery note")
            else:
                undelivered_count += 1
                print(f"DEBUG: Report {report_no} is NOT in delivery note yet")
            
            reports.append({
                "report_id": report_id,
                "report_no": report_no,
                "created_date": created_date.strftime("%Y-%m-%d") if created_date else None,
                "test_name": test_name or "Test Report",
                "sample_count": sample_count,
                "covers_samples": sample_nos,
                "already_invoiced": already_in_delivery_note,  # Using same field name for compatibility
                "status": "Delivered" if already_in_delivery_note else "Not Delivered"
            })
        
        print(f"DEBUG: Total: {len(reports)}, Delivered: {delivered_count}, Undelivered: {undelivered_count}")
        
        return {
            "project_id": project_id,
            "project_no": project_no,
            "project_name": project_name,
            "client_name": client_name,
            "total_reports": len(reports),
            "delivered_count": delivered_count,
            "undelivered_count": undelivered_count,
            "reports": reports
        }
        
    except Exception as e:
        print(f"ERROR in get_reports_for_delivery_note: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        cur.close()
        conn.close()








@router.post("/delivery-notes/generate-excel-template")
def generate_delivery_note_excel_template(payload: DeliveryNoteRequest):
    """
    Generate delivery note Excel file using the template for selected reports
    """
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get project details
        cur.execute("""
            SELECT p.project_no, p.project_name, c.name as client_name,
                   c.address, c.phone, c.email
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            WHERE p.project_id = %s
        """, (payload.project_id,))
        
        project_data = cur.fetchone()
        if not project_data:
            raise HTTPException(status_code=404, detail="Project not found")
        
        project_no, project_name, client_name, client_address, client_phone, client_email = project_data
        
        # Get selected reports or all if include_all_reports is True
        if payload.include_all_reports:
            # Get all approved reports BUT EXCLUDE ALREADY DELIVERED ONES
            cur.execute("""
                SELECT DISTINCT ON (r.report_no)
                    r.report_id, r.report_no, r.created_at,
                    r.covers_test_type as test_name,
                    r.covers_samples,
                    array_length(r.covers_samples, 1) as sample_count
                FROM reports r
                JOIN samples s ON r.sample_id = s.sample_id
                JOIN test_requests tr ON s.request_id = tr.test_request_id
                WHERE tr.project_id = %s 
                AND r.status = 'APPROVED'
                AND r.report_no NOT IN (
                    SELECT report_no FROM delivery_note_reports
                )
                ORDER BY r.report_no, r.created_at DESC
            """, (payload.project_id,))
        elif payload.selected_report_ids:
            # Get specific selected reports
            cur.execute("""
                SELECT DISTINCT ON (r.report_no)
                    r.report_id, r.report_no, r.created_at,
                    r.covers_test_type as test_name,
                    r.covers_samples,
                    array_length(r.covers_samples, 1) as sample_count
                FROM reports r
                WHERE r.report_id = ANY(%s)
                AND r.status = 'APPROVED'
                ORDER BY r.report_no, r.created_at DESC
            """, (payload.selected_report_ids,))
        else:
            raise HTTPException(status_code=400, detail="No reports selected")
        
        reports_data = cur.fetchall()
        
        if not reports_data:
            if payload.include_all_reports:
                raise HTTPException(status_code=400, detail="No undelivered reports found for this project")
            else:
                raise HTTPException(status_code=400, detail="No approved reports found for this project")
        
        # Generate delivery note number
        delivery_note_no = generate_delivery_note_number(cur)
        
        # =====================================================
        # 1. Load the Excel template
        # =====================================================
        template_path = r"C:\Users\USER\my-react-app\public\templates\delivery_note.xlsx"
        
        if not os.path.exists(template_path):
            raise HTTPException(status_code=404, detail="Delivery note template not found")
        
        wb = openpyxl.load_workbook(template_path, data_only=False)
        ws = wb.active
        
        # =====================================================
        # 2. Fill Template Fields
        # =====================================================
        # Fill Ref. No.: delivery note number
        ws["B6"] = delivery_note_no  # Ref. No.: (row 10, column B)
        
        # Fill Lab Project No.: project number
        ws["B7"] = project_no  # Lab Project No.: (row 12, column B)
        
        # Fill Customer Name:
        ws["B8"] = client_name  # Customer Name: (row 13, column B)
        
        # P.O.Box: (already has Dubai - U.A.E.)
        # This is at ws["B14"] which already has "Dubai - U.A.E."
        
        # =====================================================
        # 3. Fill Report Table
        # =====================================================
        # Starting row for reports in the template (row 19 based on your template)
        START_ROW = 12
        
        for i, report in enumerate(reports_data, 1):
            row = START_ROW + i - 1
            report_id, report_no, created_date, test_name, covers_samples, sample_count = report
            
            # Use the actual sample count from the covers_samples array
            actual_sample_count = sample_count or 1
            if covers_samples and isinstance(covers_samples, list):
                actual_sample_count = len(covers_samples)
            
            # Fill columns according to template:
            # A = Report No.
            # B = Description
            # G = No. Tests (based on your template with columns A-K)
            
            ws[f"A{row}"] = report_no
            ws[f"B{row}"] = test_name or "Test Report"
            ws[f"G{row}"] = actual_sample_count
        
        # Clear any remaining rows in the template
        MAX_TEMPLATE_ROWS = 34  # Adjust based on your template
        for row in range(START_ROW + len(reports_data), MAX_TEMPLATE_ROWS + 1):
            ws[f"A{row}"].value = None
            ws[f"B{row}"].value = None
            ws[f"G{row}"].value = None
        
        # =====================================================
        # 4. Save Final File on Server
        # =====================================================
        output_dir = r"C:\Users\USER\my-react-app\public\generated_delivery_notes"
        os.makedirs(output_dir, exist_ok=True)
        
        # Clean filename
        clean_project_no = project_no.replace('/', '-').replace(' ', '_')
        filename = f"DN-{delivery_note_no.replace('/', '-')}-{clean_project_no}.xlsx"
        filepath = os.path.join(output_dir, filename)
        
        wb.save(filepath)
        
        # =====================================================
        # 5. NEW: Track which reports were included in this delivery note
        # =====================================================
        try:
            # First ensure the delivery_note_reports junction table exists
            ensure_delivery_note_reports_table(cur)
            
            # Insert records for each report included
            for report in reports_data:
                report_no = report[1]  # report_no is at index 1
                cur.execute("""
                    INSERT INTO delivery_note_reports (delivery_note_no, report_no)
                    VALUES (%s, %s)
                    ON CONFLICT (delivery_note_no, report_no) DO NOTHING
                """, (delivery_note_no, report_no))
            
            # Update delivery_notes table - FIXED to match existing schema
            cur.execute("""
                CREATE TABLE IF NOT EXISTS delivery_notes (
                    delivery_note_id SERIAL PRIMARY KEY,
                    delivery_note_no VARCHAR(50) NOT NULL UNIQUE,
                    project_id INTEGER NOT NULL REFERENCES projects(project_id),
                    generated_by INTEGER REFERENCES users(user_id),
                    generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    total_reports INTEGER DEFAULT 0,
                    file_path TEXT
                )
            """)
            
            # Use existing user ID or default to NULL
            # In a real app, you would get this from the current user session
            user_id = None  # You might want to pass this from the frontend or use a default
            
            cur.execute("""
                INSERT INTO delivery_notes 
                (delivery_note_no, project_id, generated_by, total_reports, file_path)
                VALUES (%s, %s, %s, %s, %s)
            """, (delivery_note_no, payload.project_id, user_id, len(reports_data), filepath))
            
            conn.commit()
        except Exception as db_error:
            print(f"Note: Could not save delivery note record: {db_error}")
            # Don't fail the request if we can't save the record
            if conn:
                conn.rollback()
        
        # =====================================================
        # 6. Return File for Download
        # =====================================================
        return FileResponse(
            filepath,
            filename=filename,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in generate_delivery_note_excel_template: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error generating delivery note: {str(e)}")
    finally:
        cur.close()
        conn.close()









@router.get("/projects/{project_id}/reports-for-invoice/{invoice_type}")
def get_reports_for_invoice(project_id: int, invoice_type: str):
    """
    Get all approved reports for a project to select for PROFORMA or TAX invoice
    Similar to delivery notes but checks invoice_report_links table
    """
    if invoice_type not in ['PROFORMA', 'TAX']:
        raise HTTPException(status_code=400, detail="Invoice type must be PROFORMA or TAX")
    
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get project details
        cur.execute(""" 
            SELECT p.project_no, p.project_name, c.name as client_name
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            WHERE p.project_id = %s
        """, (project_id,))
        
        project_data = cur.fetchone()
        if not project_data:
            raise HTTPException(status_code=404, detail="Project not found")
        
        project_no, project_name, client_name = project_data
        
        print(f"DEBUG: Fetching reports for {invoice_type} invoice - project {project_id}")
        
        # Get all approved reports for this project
        # Check if they're already in invoice_report_links for this invoice type
        cur.execute("""
            SELECT DISTINCT ON (r.report_no)
                r.report_id, 
                r.report_no, 
                r.created_at,
                r.covers_test_type as test_name,
                r.covers_samples,
                -- Count samples in the covers_samples array
                array_length(r.covers_samples, 1) as sample_count,
                -- Check if already in PROFORMA/TAX invoices
                EXISTS (
                    SELECT 1 FROM invoice_report_links irl
                    WHERE irl.report_no = r.report_no 
                    AND irl.invoice_type = %s
                ) as already_invoiced
            FROM reports r
            JOIN samples s ON r.sample_id = s.sample_id
            JOIN test_requests tr ON s.request_id = tr.test_request_id
            WHERE tr.project_id = %s 
            AND r.status = 'APPROVED'
            ORDER BY r.report_no, r.created_at DESC
        """, (invoice_type, project_id))
        
        all_reports = cur.fetchall()
        
        print(f"DEBUG: Found {len(all_reports)} approved reports for {invoice_type}")
        
        reports = []
        invoiced_count = 0
        uninvoiced_count = 0
        
        for row in all_reports:
            report_id = row[0]
            report_no = row[1]
            created_date = row[2]
            test_name = row[3]
            covers_samples = row[4]
            sample_count = row[5] or 0
            already_invoiced = row[6]
            
            # Get the actual sample numbers from the array if available
            sample_nos = []
            if covers_samples and len(covers_samples) > 0:
                # Join with samples table to get sample numbers
                placeholders = ','.join(['%s'] * len(covers_samples))
                cur.execute(f"""
                    SELECT sample_no FROM samples 
                    WHERE sample_no IN ({placeholders})
                """, tuple(covers_samples))
                sample_rows = cur.fetchall()
                sample_nos = [row[0] for row in sample_rows] if sample_rows else []
            else:
                # Fallback: get the sample_no for this specific report
                cur.execute("""
                    SELECT s.sample_no FROM samples s
                    WHERE s.sample_id = (
                        SELECT sample_id FROM reports 
                        WHERE report_no = %s LIMIT 1
                    )
                """, (report_no,))
                sample_row = cur.fetchone()
                if sample_row:
                    sample_nos = [sample_row[0]]
                    sample_count = 1
            
            if already_invoiced:
                invoiced_count += 1
                print(f"DEBUG: Report {report_no} is already in {invoice_type} invoice")
            else:
                uninvoiced_count += 1
                print(f"DEBUG: Report {report_no} is NOT in {invoice_type} invoice yet")
            
            reports.append({
                "report_id": report_id,
                "report_no": report_no,
                "created_date": created_date.strftime("%Y-%m-%d") if created_date else None,
                "test_name": test_name or "Test Report",
                "sample_count": sample_count,
                "covers_samples": sample_nos,
                "already_invoiced": already_invoiced,
                "invoice_type": invoice_type,
                "status": "Invoiced" if already_invoiced else "Not Invoiced"
            })
        
        print(f"DEBUG: Total: {len(reports)}, {invoice_type} Invoiced: {invoiced_count}, Not Invoiced: {uninvoiced_count}")
        
        return {
            "project_id": project_id,
            "project_no": project_no,
            "project_name": project_name,
            "client_name": client_name,
            "invoice_type": invoice_type,
            "total_reports": len(reports),
            "invoiced_count": invoiced_count,
            "uninvoiced_count": uninvoiced_count,
            "reports": reports
        }
        
    except Exception as e:
        print(f"ERROR in get_reports_for_invoice: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        cur.close()
        conn.close()


# =====================================================
# MODIFIED: Create Invoice - Record report links
# =====================================================
@router.post("/with-reports", response_model=InvoiceOut)
def create_invoice_with_reports(payload: InvoiceCreate, selection: Optional[InvoiceReportSelection] = None):
    """
    Create a new invoice for a project with optional report selection.
    If invoice_type is PROFORMA or TAX and selection is provided, record report links.
    """
    conn = get_connection()
    cur = conn.cursor()

    try:
        # ---------------------------------------------------
        # 1. Get project details with client info
        # ---------------------------------------------------
        cur.execute("""
            SELECT p.project_id, p.project_no, p.project_name, p.location, p.lpo_no, p.lpo_date,
                   c.client_id, c.name, c.contact_person, c.email, c.address, c.phone,
                   q.quotation_no
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            JOIN quotations q ON p.quotation_id = q.quotation_id
            WHERE p.project_id = %s
        """, (payload.project_id,))
        project_data = cur.fetchone()
        if not project_data:
            raise HTTPException(status_code=404, detail="Project not found")

        # ---------------------------------------------------
        # 2. Get invoiceable items from project
        # ---------------------------------------------------
        invoiceable_items = get_project_quotation_items(payload.project_id, cur)
        if not invoiceable_items:
            raise HTTPException(status_code=400, detail="No test items available for invoicing")

        # ---------------------------------------------------
        # 2a. Group invoiceable items by description, test standard, unit rate
        # ---------------------------------------------------
        from collections import defaultdict

        grouped_items = defaultdict(lambda: {
            "description": "",
            "test_standard": "",
            "unit_rate": 0,
            "quantity": 0,
            "sample_ids": []
        })

        for item in invoiceable_items:
            item_id, description, test_standard, unit_rate, quantity, test_request_id, request_no, sample_id, sample_no, sample_status = item
            key = (description, test_standard, unit_rate)
            grouped_items[key]["description"] = description
            grouped_items[key]["test_standard"] = test_standard
            grouped_items[key]["unit_rate"] = unit_rate
            grouped_items[key]["quantity"] += quantity
            grouped_items[key]["sample_ids"].append(sample_id)

        # Convert grouped items to a list
        final_items = []
        for (desc, std, rate), data in grouped_items.items():
            final_items.append((desc, std, rate, data["quantity"], data["sample_ids"]))

        # ---------------------------------------------------
        # 3. Generate invoice number
        # ---------------------------------------------------
        invoice_no = generate_invoice_no(cur, payload.invoice_type)

        # ---------------------------------------------------
        # 4. Calculate totals
        # ---------------------------------------------------
        subtotal = 0.0
        for item in final_items:
            desc, std, unit_rate, quantity, sample_ids = item
            unit_rate_float = float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate
            subtotal += unit_rate_float * quantity

        vat = subtotal * 0.05  # 5% VAT
        total = subtotal + vat
        amount_words = number_to_words(total)

        # ---------------------------------------------------
        # 5. LPO and payment terms
        # ---------------------------------------------------
        lpo_reference = payload.lpo_reference or project_data[4]
        lpo_date = payload.lpo_date or project_data[5]
        payment_terms = payload.payment_terms or "30 days"

        # ---------------------------------------------------
        # 6. Insert invoice header
        # ---------------------------------------------------
        cur.execute("""
            INSERT INTO invoices (
                invoice_no, project_id, invoice_type, invoice_date,
                client_reference, lpo_reference, lpo_date, payment_terms,
                subtotal, vat, total, amount_in_words, services_description, remarks
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING invoice_id
        """, (
            invoice_no,
            payload.project_id,
            payload.invoice_type,
            payload.invoice_date or date.today(),
            payload.client_reference,
            lpo_reference,
            lpo_date,
            payment_terms,
            subtotal,
            vat,
            total,
            amount_words,
            payload.services_description or f"Testing services for {project_data[2]}",
            payload.remarks
        ))
        invoice_id = cur.fetchone()[0]

        # ---------------------------------------------------
        # 7. Insert grouped invoice items
        # ---------------------------------------------------
        for item in final_items:
            description, test_standard, unit_rate, quantity, sample_ids = item
            unit_rate_float = float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate
            amount = unit_rate_float * quantity
            sample_id = sample_ids[0] if sample_ids else None  # representative sample

            cur.execute("""
                INSERT INTO invoice_items (
                    invoice_id, description, test_standard,
                    unit_rate, quantity, amount, sample_id
                )
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (
                invoice_id,
                description,
                test_standard,
                unit_rate_float,
                quantity,
                amount,
                sample_id
            ))

        # ---------------------------------------------------
        # 8. Record report links for PROFORMA/TAX invoices
        # ---------------------------------------------------
        if payload.invoice_type in ['PROFORMA', 'TAX'] and selection:
            # Determine which reports to include
            if selection.include_all_reports:
                # Get all approved reports NOT already in this invoice type
                cur.execute("""
                    SELECT DISTINCT r.report_no
                    FROM reports r
                    JOIN samples s ON r.sample_id = s.sample_id
                    JOIN test_requests tr ON s.request_id = tr.test_request_id
                    WHERE tr.project_id = %s 
                    AND r.status = 'APPROVED'
                    AND r.report_no NOT IN (
                        SELECT report_no FROM invoice_report_links 
                        WHERE invoice_type = %s
                    )
                """, (payload.project_id, payload.invoice_type))
                report_nos = [row[0] for row in cur.fetchall()]
            elif selection.selected_report_ids:
                # Get specific selected reports
                cur.execute("""
                    SELECT DISTINCT r.report_no
                    FROM reports r
                    WHERE r.report_id = ANY(%s)
                    AND r.status = 'APPROVED'
                """, (selection.selected_report_ids,))
                report_nos = [row[0] for row in cur.fetchall()]
            else:
                report_nos = []
            
            # Insert into invoice_report_links
            for report_no in report_nos:
                cur.execute("""
                    INSERT INTO invoice_report_links (invoice_id, report_no, invoice_type)
                    VALUES (%s, %s, %s)
                    ON CONFLICT (invoice_id, report_no, invoice_type) DO NOTHING
                """, (invoice_id, report_no, payload.invoice_type))

        # ---------------------------------------------------
        # 9. Commit transaction
        # ---------------------------------------------------
        conn.commit()

        # ---------------------------------------------------
        # 10. Return complete invoice
        # ---------------------------------------------------
        return get_invoice_complete(invoice_id, cur)

    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()


# =====================================================
# NEW: Generate Invoice with Report Selection
# =====================================================
@router.post("/generate-with-reports")
def generate_invoice_with_reports(payload: dict):
    """
    Combined endpoint to create invoice, record report links, and generate Excel
    """
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        print(f"DEBUG: Received payload for generate-with-reports: {payload}")
        
        # Extract data from payload
        project_id = payload.get("project_id")
        invoice_type = payload.get("invoice_type")  # This should be "PROFORMA" or "TAX"
        document_type = payload.get("document_type")  # This is the actual document type
        
        # For backward compatibility, use document_type if invoice_type is not provided
        if not invoice_type and document_type in ["PROFORMA", "TAX"]:
            invoice_type = document_type
        
        print(f"DEBUG: Creating {invoice_type} invoice for project {project_id}")
        
        # Check if it's PROFORMA or TAX invoice
        is_PROFORMA_or_tax = invoice_type in ["PROFORMA", "TAX"]
        
        # Create invoice payload
        invoice_payload = {
            "project_id": project_id,
            "invoice_type": invoice_type if is_PROFORMA_or_tax else payload.get("invoice_type", "CASH"),
            "invoice_date": payload.get("invoice_date") or date.today().isoformat(),
            "client_reference": payload.get("client_reference"),
            "lpo_reference": payload.get("lpo_reference"),
            "lpo_date": payload.get("lpo_date"),
            "payment_terms": payload.get("payment_terms") or ("30 days" if is_PROFORMA_or_tax else "Immediate"),
            "services_description": payload.get("services_description") or "Professional services rendered",
            "remarks": payload.get("remarks")
        }
        
        print(f"DEBUG: Invoice payload: {invoice_payload}")
        
        # Create the invoice
        invoice_create = InvoiceCreate(**invoice_payload)
        invoice_result = create_invoice(invoice_create)
        invoice_id = invoice_result["invoice_id"]

        
        print(f"DEBUG: Created invoice {invoice_result['invoice_no']} with ID {invoice_id}")

        
        # For PROFORMA/TAX invoices, record report links
        if is_PROFORMA_or_tax:
            include_all_reports = payload.get("include_all_reports", True)
            selected_report_ids = payload.get("selected_report_ids")
            
            print(f"DEBUG: Recording report links for {invoice_type} invoice")
            print(f"DEBUG: include_all_reports: {include_all_reports}")
            print(f"DEBUG: selected_report_ids: {selected_report_ids}")
            
            # Determine which reports to include
            if include_all_reports:
                # Get all approved reports NOT already in this invoice type
                cur.execute("""
                    SELECT DISTINCT r.report_no
                    FROM reports r
                    JOIN samples s ON r.sample_id = s.sample_id
                    JOIN test_requests tr ON s.request_id = tr.test_request_id
                    WHERE tr.project_id = %s 
                    AND r.status = 'APPROVED'
                    AND r.report_no NOT IN (
                        SELECT report_no FROM invoice_report_links 
                        WHERE invoice_type = %s
                    )
                """, (project_id, invoice_type))
                report_nos = [row[0] for row in cur.fetchall()]
            elif selected_report_ids:
                # Get specific selected reports
                cur.execute("""
                    SELECT DISTINCT r.report_no
                    FROM reports r
                    WHERE r.report_id = ANY(%s)
                    AND r.status = 'APPROVED'
                """, (selected_report_ids,))
                report_nos = [row[0] for row in cur.fetchall()]
            else:
                report_nos = []
            
            print(f"DEBUG: Will link {len(report_nos)} reports to invoice")
            
            # Insert into invoice_report_links
            for report_no in report_nos:
                try:
                    cur.execute("""
                        INSERT INTO invoice_report_links (invoice_id, report_no, invoice_type)
                        VALUES (%s, %s, %s)
                        ON CONFLICT (invoice_id, report_no, invoice_type) DO NOTHING
                    """, (invoice_id, report_no, invoice_type))
                    print(f"DEBUG: Linked report {report_no} to invoice")
                except Exception as e:
                    print(f"WARNING: Could not link report {report_no}: {e}")
            
            conn.commit()
            print(f"DEBUG: Report links committed to database")
        
        # Generate Excel file
        print(f"DEBUG: Generating Excel for invoice {invoice_id}")
        return generate_excel_invoice(invoice_id)
        
    except Exception as e:
        print(f"ERROR in generate_invoice_with_reports: {str(e)}")
        traceback.print_exc()
        if conn:
            conn.rollback()
        raise HTTPException(status_code=500, detail=f"Error generating invoice: {str(e)}")
    finally:
        cur.close()
        conn.close()


# Add this endpoint to invoices.py, after the existing endpoints

@router.get("/projects/{project_id}/reports-invoiced-status")
def get_reports_invoiced_status(project_id: int):
    """
    Get all approved reports for a project with combined invoice/delivery status
    Shows "Invoiced" if in PROFORMA/TAX invoice OR delivery note
    Shows "Uninvoiced" if in neither
    """
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get project details
        cur.execute(""" 
            SELECT p.project_no, p.project_name, c.name as client_name
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            WHERE p.project_id = %s
        """, (project_id,))
        
        project_data = cur.fetchone()
        if not project_data:
            raise HTTPException(status_code=404, detail="Project not found")
        
        project_no, project_name, client_name = project_data
        
        # Get all approved reports with combined invoice/delivery status
        cur.execute("""
            SELECT DISTINCT ON (r.report_no)
                r.report_id, 
                r.report_no, 
                r.created_at,
                r.covers_test_type as test_name,
                r.covers_samples,
                array_length(r.covers_samples, 1) as sample_count,
                -- Combined status
                CASE 
                    WHEN EXISTS (
                        SELECT 1 FROM invoice_report_links irl
                        WHERE irl.report_no = r.report_no 
                        AND irl.invoice_type IN ('PROFORMA', 'TAX')
                    ) OR EXISTS (
                        SELECT 1 FROM delivery_note_reports dnr
                        WHERE dnr.report_no = r.report_no
                    ) THEN true
                    ELSE false
                END as is_invoiced
            FROM reports r
            JOIN samples s ON r.sample_id = s.sample_id
            JOIN test_requests tr ON s.request_id = tr.test_request_id
            WHERE tr.project_id = %s 
            AND r.status = 'APPROVED'
            ORDER BY r.report_no, r.created_at DESC
        """, (project_id,))
        
        all_reports = cur.fetchall()
        
        reports = []
        for row in all_reports:
            report_id = row[0]
            report_no = row[1]
            created_date = row[2]
            test_name = row[3]
            covers_samples = row[4]
            sample_count = row[5] or 0
            is_invoiced = row[6]
            
            # Get sample numbers from covers_samples array
            sample_nos = []
            if covers_samples and len(covers_samples) > 0:
                # Try to get sample numbers directly from the array
                sample_nos = [str(s) for s in covers_samples if s]
            
            reports.append({
                "report_id": report_id,
                "report_no": report_no,
                "created_date": created_date,
                "test_name": test_name or "Test Report",
                "sample_count": sample_count,
                "covers_samples": sample_nos,
                "is_invoiced": is_invoiced,
                "invoice_status": "Invoiced" if is_invoiced else "Uninvoiced"
            })
        
        return {
            "project_id": project_id,
            "project_no": project_no,
            "project_name": project_name,
            "client_name": client_name,
            "total_reports": len(reports),
            "reports": reports
        }
        
    except Exception as e:
        print(f"ERROR in get_reports_invoiced_status: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        cur.close()
        conn.close()




@router.post("/generate-proforma-for-report")
def generate_proforma_for_report(payload: dict):
    """
    Generate Proforma Invoice for a specific report
    """
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        print(f"DEBUG: Generating proforma invoice for report: {payload}")
        
        project_id = payload.get("project_id")
        report_id = payload.get("report_id")
        report_no = payload.get("report_no")
        
        if not project_id or not report_id:
            raise HTTPException(status_code=400, detail="Project ID and Report ID are required")
        
        # Get project details
        cur.execute("""
            SELECT p.project_id, p.project_no, p.project_name, p.location, p.lpo_no, p.lpo_date,
                   c.client_id, c.name, c.contact_person, c.email, c.address, c.phone,
                   q.quotation_no
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            JOIN quotations q ON p.quotation_id = q.quotation_id
            WHERE p.project_id = %s
        """, (project_id,))
        
        project_data = cur.fetchone()
        if not project_data:
            raise HTTPException(status_code=404, detail="Project not found")
        
        # Get the specific report details
        if report_no:
            cur.execute("""
                SELECT r.report_id, r.report_no, r.covers_test_type, 
                       r.covers_samples, r.sample_id, r.created_at
                FROM reports r
                WHERE r.report_no = %s AND r.status = 'APPROVED'
            """, (report_no,))
        else:
            cur.execute("""
                SELECT r.report_id, r.report_no, r.covers_test_type, 
                       r.covers_samples, r.sample_id, r.created_at
                FROM reports r
                WHERE r.report_id = %s AND r.status = 'APPROVED'
            """, (report_id,))
        
        report_data = cur.fetchone()
        if not report_data:
            raise HTTPException(status_code=404, detail="Report not found or not approved")
        
        report_id, report_no, test_type, covers_samples, sample_id, created_at = report_data
        
        # Get sample count from the report
        sample_count = len(covers_samples) if covers_samples else 1
        print(f"DEBUG: Report {report_no} covers {sample_count} samples: {covers_samples}")
        
        # Get test items for this report
        invoiceable_items = get_project_quotation_items(project_id, cur)
        
        # Find the item that matches this report's test type
        matching_items = []
        for item in invoiceable_items:
            item_id, description, test_standard, unit_rate, quantity, test_request_id, request_no, sample_id_item, sample_no, sample_status = item
            
            # Check if this test type matches the report
            if test_type and description and test_type.lower() in description.lower():
                matching_items.append({
                    "quotation_item_id": item_id,
                    "description": description,
                    "test_standard": test_standard,
                    "unit_rate": unit_rate,
                    "quantity": sample_count,  # Use the actual sample count
                    "sample_id": sample_id_item if sample_id_item else sample_id
                })
                print(f"DEBUG: Found matching item: {description}, quantity: {sample_count}")
                break
        
        if not matching_items:
            # If no exact match, use the first item
            if invoiceable_items:
                item = invoiceable_items[0]
                matching_items.append({
                    "quotation_item_id": item[0],
                    "description": test_type or item[1],
                    "test_standard": item[2],
                    "unit_rate": item[3],
                    "quantity": sample_count,  # ‚úÖ FIXED: Use actual sample count here too
                    "sample_id": item[7] if item[7] else sample_id
                })
                print(f"DEBUG: Using fallback item: {test_type or item[1]}, quantity: {sample_count}")
            else:
                raise HTTPException(status_code=400, detail="No invoiceable items found for this project")
        
        # Generate invoice number
        invoice_no = generate_invoice_no(cur, "PROFORMA")
        
        # Calculate totals based on matching items
        subtotal = 0.0
        for item in matching_items:
            unit_rate_float = float(item["unit_rate"]) if isinstance(item["unit_rate"], Decimal) else item["unit_rate"]
            item_amount = unit_rate_float * item["quantity"]
            subtotal += item_amount
            print(f"DEBUG: Item calculation: {unit_rate_float} x {item['quantity']} = {item_amount}")
        
        vat = subtotal * 0.05  # 5% VAT
        total = subtotal + vat
        amount_words = number_to_words(total)
        
        print(f"DEBUG: Financials - Subtotal: {subtotal}, VAT: {vat}, Total: {total}")
        
        # Create the invoice
        invoice_date = date.today()
        
        # Use today's date for LPO date if not available
        lpo_reference = project_data[4] or f"PROFORMA-{report_no}"
        lpo_date = project_data[5] or invoice_date
        
        # Create invoice data structure for Excel generation
        invoice_data = {
            "invoice_no": invoice_no,
            "project_id": project_id,
            "invoice_type": "PROFORMA",
            "invoice_date": invoice_date,
            "client_reference": f"Proforma for Report: {report_no}",
            "lpo_reference": lpo_reference,
            "lpo_date": lpo_date,
            "payment_terms": "Proforma Invoice - Payment on delivery",
            "subtotal": subtotal,
            "vat": vat,
            "total": total,
            "amount_in_words": amount_words,
            "services_description": f"Testing services for report {report_no}",
            "remarks": f"Proforma invoice for test report {report_no}",
            "project_details": {
                "project_no": project_data[1],
                "project_name": project_data[2],
                "location": project_data[3],
                "client_name": project_data[7],
                "client_contact": project_data[8],
                "client_email": project_data[9],
                "client_address": project_data[10],
                "client_phone": project_data[11]
            },
            "items": [
                {
                    "description": item["description"],
                    "test_standard": item["test_standard"],
                    "unit_rate": float(item["unit_rate"]) if isinstance(item["unit_rate"], Decimal) else item["unit_rate"],
                    "quantity": item["quantity"],
                    "amount": (float(item["unit_rate"]) if isinstance(item["unit_rate"], Decimal) else item["unit_rate"]) * item["quantity"],
                    "sample_id": item["sample_id"],
                    "sample_no": f"Report-{report_no} ({item['quantity']} samples)",
                    "sample_status": "COMPLETED"
                }
                for item in matching_items
            ]
        }
        
        # =====================================================
        # Generate Excel using existing template
        # =====================================================
        template_path = r"C:\Users\USER\my-react-app\public\templates\invoice.xlsx"
        
        if not os.path.exists(template_path):
            raise HTTPException(status_code=404, detail="Invoice template not found")
        
        wb = openpyxl.load_workbook(template_path, data_only=False)
        ws = wb.active
        
        # Fill template fields
        ws["I4"] = invoice_no
        ws["I5"] = invoice_date.strftime("%d-%b-%Y")
        ws["A5"] = invoice_data["project_details"]["client_name"]
        ws["C10"] = invoice_data["project_details"]["client_contact"]
        ws["C13"] = invoice_data["project_details"]["project_no"]
        ws["C15"] = invoice_data["project_details"]["project_name"]
        ws["C14"] = invoice_data["project_details"]["location"]
        ws["C18"] = lpo_reference
        ws["I6"] = lpo_date.strftime("%d-%b-%Y") if hasattr(lpo_date, 'strftime') else str(lpo_date)
        ws["I8"] = "PROFORMA / Immediate"
        
        # Fill report details in items section
        FIRST_ITEM_ROW = 18
        
        # Clear existing rows
        for row in range(FIRST_ITEM_ROW, 35):
            for col in ['A', 'B', 'D', 'E', 'I', 'J', 'K']:
                ws[f"{col}{row}"].value = None
        
        # Fill the first row with report data
        row = FIRST_ITEM_ROW
        item = invoice_data["items"][0]
        
        ws[f"A{row}"] = report_no
        ws[f"B{row}"] = created_at.strftime("%d-%b-%Y") if hasattr(created_at, 'strftime') else " - "
        ws[f"D{row}"] = item["description"]
        ws[f"E{row}"] = item["test_standard"] or " - "
        quantity = item.get("quantity", 1)
        if isinstance(quantity, list):
            quantity = len(quantity)
        ws[f"I{row}"] = quantity
        ws[f"J{row}"] = item["unit_rate"]
        ws[f"K{row}"] = item["amount"]
        
        # Update formulas
        ws["K35"].value = f"=K{FIRST_ITEM_ROW}"
        ws["K36"].value = "=K35*0.05"
        ws["K37"].value = "=K35+K36"
        ws["B38"] = amount_words  # ‚úÖ FIXED: Use the actual amount words
        
        # Save the file
        output_dir = r"C:\Users\USER\my-react-app\public\generated_proforma"
        os.makedirs(output_dir, exist_ok=True)
        
        # Create filename
        clean_report_no = report_no.replace('/', '-').replace(' ', '_')
        filename = f"Proforma-{clean_report_no}.xlsx"
        filepath = os.path.join(output_dir, filename)
        
        wb.save(filepath)
        
        print(f"DEBUG: Proforma invoice saved to {filepath}")
        print(f"DEBUG: Quantity in invoice: {quantity}, Amount: {item['amount']}")
        
        # Return the file for download
        return FileResponse(
            filepath,
            filename=filename,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )
        
    except Exception as e:
        print(f"ERROR in generate_proforma_for_report: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error generating proforma invoice: {str(e)}")
    finally:
        cur.close()
        conn.close()

