###############################################################
1. Enquiries
###############################################################
# enquiries.py - FIXED VERSION
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from datetime import date, datetime
from typing import Optional, List
from db import get_connection

router = APIRouter(prefix="/enquiries", tags=["2. Enquiries"])

# ----------------------------
# Pydantic Models
# ----------------------------
class EnquiryCreate(BaseModel):
    client_id: int
    enquiry_ref: Optional[str] = None
    enquiry_date: Optional[date] = None
    project_name: Optional[str] = None
    location: Optional[str] = None
    notes: Optional[str] = None

class EnquiryOut(BaseModel):
    enquiry_id: int
    enquiry_ref: str
    client_id: int
    enquiry_date: Optional[date]
    project_name: Optional[str]
    location: Optional[str]
    status: str
    notes: Optional[str]

############################################
class ClientOut(BaseModel):
    client_id: int
    name: str
    email: Optional[str] = None
    phone: Optional[str] = None

# ----------------------------
# CLIENT ENDPOINTS
# ----------------------------
@router.get("/clients/", response_model=List[ClientOut])
def get_clients():
    """Get all clients for dropdown selection"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Query to get all clients
        cur.execute("""
            SELECT client_id,name, email, phone 
            FROM clients 
            ORDER BY name ASC
        """)
        
        clients = cur.fetchall()
        
        # Format response
        client_list = []
        for client in clients:
            client_list.append({
                "client_id": client[0],
                "name": client[1],
                "email": client[2],
                "phone": client[3]
            })
        
        return client_list
        
    except Exception as e:
        print(f"Error fetching clients: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()



@router.get("/clients/{client_id}", response_model=ClientOut)
def get_client_by_id(client_id: int):
    """Get specific client by ID"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT client_id, name, email, phone 
            FROM clients 
            WHERE client_id = %s
        """, (client_id,))
        
        client = cur.fetchone()
        
        if not client:
            raise HTTPException(status_code=404, detail="Client not found")
        
        return {
            "client_id": client[0],
            "name": client[1],
            "email": client[2],
            "phone": client[3]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching client: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()



#####################################

# ----------------------------
# FIXED Generate Auto Enquiry Ref
# ----------------------------
def _generate_enquiry_ref(cur):
    year = datetime.utcnow().year
    # FIX: Check for existing enquiries in the current year
    cur.execute(
        "SELECT COUNT(*) FROM enquiries WHERE EXTRACT(YEAR FROM enquiry_date) = %s",
        (year,),
    )
    count_result = cur.fetchone()
    count = count_result[0] if count_result else 0
    count += 1
    return f"ENQ-{year}-{count:03d}"

# ----------------------------
# CREATE ENQUIRY - FIXED
# ----------------------------
@router.post("/", response_model=EnquiryOut)
def create_enquiry(payload: EnquiryCreate):
    conn = get_connection()
    cur = conn.cursor()

    try:
        # Ensure client exists
        cur.execute("SELECT client_id FROM clients WHERE client_id = %s", (payload.client_id,))
        if cur.fetchone() is None:
            raise HTTPException(status_code=404, detail="Client not found")

        # Default enquiry_date to today
        enquiry_date = payload.enquiry_date or date.today()

        # Generate ref if user didn't supply - FIXED LOGIC
        if payload.enquiry_ref:
            enquiry_ref = payload.enquiry_ref
        else:
            enquiry_ref = _generate_enquiry_ref(cur)

        print(f"Generated enquiry_ref: {enquiry_ref}")  # Debug log

        # Insert enquiry
        cur.execute(
            """
            INSERT INTO enquiries (
                client_id, enquiry_ref, enquiry_date, project_name, location, status, notes
            )
            VALUES (%s, %s, %s, %s, %s, 'OPEN', %s)
            RETURNING enquiry_id, enquiry_ref, client_id, enquiry_date, project_name, location, status, notes
            """,
            (
                payload.client_id,
                enquiry_ref,  # This should never be NULL now
                enquiry_date,
                payload.project_name,
                payload.location,
                payload.notes,
            ),
        )

        row = cur.fetchone()
        conn.commit()

        # Debug: Print what we're returning
        print(f"Returning row: {row}")

        return {
            "enquiry_id": row[0],
            "enquiry_ref": row[1] or "ERROR-MISSING-REF",  # Fallback if still NULL
            "client_id": row[2],
            "enquiry_date": row[3],
            "project_name": row[4],
            "location": row[5],
            "status": row[6],
            "notes": row[7],
        }

    except Exception as e:
        conn.rollback()
        print(f"Error in create_enquiry: {str(e)}")  # Debug log
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        cur.close()
        conn.close()

# ----------------------------
# LIST ENQUIRIES - FIXED with NULL handling
# ----------------------------
@router.get("/", response_model=List[EnquiryOut])
def list_enquiries(limit: int = 100, offset: int = 0):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute(
            """
            SELECT enquiry_id, enquiry_ref, client_id,
                   enquiry_date, project_name, location,
                   status, notes
            FROM enquiries
            ORDER BY enquiry_id DESC
            LIMIT %s OFFSET %s
            """,
            (limit, offset),
        )

        rows = cur.fetchall()

        enquiries = []
        for r in rows:
            # FIX: Handle NULL enquiry_ref
            enquiry_ref = r[1] or f"ENQ-{r[3].year if r[3] else datetime.now().year}-MISSING-{r[0]}"
            
            enquiries.append({
                "enquiry_id": r[0],
                "enquiry_ref": enquiry_ref,
                "client_id": r[2],
                "enquiry_date": r[3],
                "project_name": r[4],
                "location": r[5],
                "status": r[6],
                "notes": r[7],
            })

        return enquiries

    except Exception as e:
        print(f"Error in list_enquiries: {str(e)}")  # Debug log
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        cur.close()
        conn.close()


@router.get("/recent", response_model=List[EnquiryOut])
def recent_enquiries(limit: int = 10):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            SELECT enquiry_id, enquiry_ref, client_id,
                   enquiry_date, project_name,
                   location, status, notes
            FROM enquiries
            ORDER BY enquiry_id DESC
            LIMIT %s
        """, (limit,))

        return [
            {
                "enquiry_id": r[0],
                "enquiry_ref": r[1] or f"ENQ-{r[0]}",
                "client_id": r[2],
                "enquiry_date": r[3],
                "project_name": r[4],
                "location": r[5],
                "status": r[6],
                "notes": r[7],
            }
            for r in cur.fetchall()
        ]

    finally:
        cur.close()
        conn.close()


# ============================================================
# SEARCH ENQUIRIES
# ============================================================

@router.get("/search", response_model=List[EnquiryOut])
def search_enquiries(q: str):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            SELECT e.enquiry_id, e.enquiry_ref, e.client_id,
                   e.enquiry_date, e.project_name,
                   e.location, e.status, e.notes
            FROM enquiries e
            JOIN clients c ON c.client_id = e.client_id
            WHERE
                e.enquiry_ref ILIKE %s OR
                e.project_name ILIKE %s OR
                e.location ILIKE %s OR
                c.name ILIKE %s
            ORDER BY e.enquiry_id DESC
        """, tuple([f"%{q}%"] * 4))

        return [
            {
                "enquiry_id": r[0],
                "enquiry_ref": r[1],
                "client_id": r[2],
                "enquiry_date": r[3],
                "project_name": r[4],
                "location": r[5],
                "status": r[6],
                "notes": r[7],
            }
            for r in cur.fetchall()
        ]

    finally:
        cur.close()
        conn.close()

# ----------------------------
# UPDATE ENQUIRY STATUS (unchanged)
# ----------------------------
@router.post("/{enquiry_id}/status")
def update_enquiry_status(enquiry_id: int, status: str):
    conn = get_connection()
    cur = conn.cursor()

    try:
        # Ensure enquiry exists
        cur.execute("SELECT enquiry_id FROM enquiries WHERE enquiry_id = %s", (enquiry_id,))
        if cur.fetchone() is None:
            raise HTTPException(status_code=404, detail="Enquiry not found")

        # Update status
        cur.execute("UPDATE enquiries SET status = %s WHERE enquiry_id = %s", (status, enquiry_id))
        conn.commit()

        return {"message": "Status updated", "enquiry_id": enquiry_id, "status": status}

    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        cur.close()
        conn.close()




###############################################################
2. Invoices
###############################################################

# invoices.py - COMPLETE FIXED VERSION
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, List, Literal
from datetime import date, datetime
from db import get_connection
from decimal import Decimal
from fastapi.responses import HTMLResponse


from fastapi.responses import FileResponse
import openpyxl
from datetime import datetime
import os

router = APIRouter(prefix="/invoices", tags=["6. Invoices"])

# ----------------------------
# Pydantic Models
# ----------------------------
class InvoiceItemCreate(BaseModel):
    quotation_item_id: int
    quantity: int = 1
    sample_id: Optional[int] = None

class InvoiceCreate(BaseModel):
    project_id: int
    invoice_type: Literal['CASH', 'CREDIT']
    invoice_date: Optional[date] = None
    client_reference: Optional[str] = None
    lpo_reference: Optional[str] = None
    lpo_date: Optional[date] = None
    payment_terms: Optional[str] = "30 days"
    services_description: Optional[str] = None
    remarks: Optional[str] = None

class InvoiceOut(BaseModel):
    invoice_id: int
    invoice_no: str
    project_id: int
    invoice_type: str
    invoice_date: date
    client_reference: Optional[str]
    lpo_reference: Optional[str]
    lpo_date: Optional[date]
    payment_terms: Optional[str]
    subtotal: float
    vat: float
    total: float
    amount_in_words: str
    services_description: Optional[str]
    remarks: Optional[str]
    payment_status: str
    paid_date: Optional[date]
    items: List[dict]
    project_details: dict

# ----------------------------
# Utility Functions - FIXED
# ----------------------------
def number_to_words(num: float) -> str:
    """Convert number to words for amount in words field"""
    return f" {num:,.2f} United Arab Emirates Dirhams Only"

def generate_invoice_no(cur, invoice_type: str) -> str:
    """Generate invoice number: continuously incrementing like 36001/25, 36002/25, 36003/26"""
    # Get the last 2 digits of current year
    year_short = str(datetime.now().year)[-2:]
    
    # Get the max invoice number overall
    cur.execute("""
        SELECT invoice_no 
        FROM invoices 
        ORDER BY invoice_id DESC 
        LIMIT 1
    """)
    
    last_invoice = cur.fetchone()
    
    if last_invoice:
        # Parse existing invoice number
        try:
            last_number = int(last_invoice[0].split('/')[0])
            next_number = last_number + 1
        except (ValueError, IndexError):
            # If parsing fails, start from 36001
            next_number = 36001
    else:
        # First invoice ever
        next_number = 36001
    
    return f"{next_number}/{year_short}"

# ----------------------------
# Assignment Logic - SAME AS WORKSHEET GENERATION
# ----------------------------

def get_assigned_test_for_sample(sample_id: int, cur):
    """Get the assigned test for a sample - SAME LOGIC AS WORKSHEET GENERATION"""
    # Get sample's test request
    cur.execute("SELECT request_id FROM samples WHERE sample_id = %s", (sample_id,))
    sample_data = cur.fetchone()
    if not sample_data:
        return None
    
    request_id = sample_data[0]
    
    # Get all tests for this request
    cur.execute("""
        SELECT qi.item_id, qi.item_code, qi.description, qi.test_standard, qi.unit_rate,
               tri.quantity, tri.tri_id,
               ROW_NUMBER() OVER (ORDER BY tri.tri_id) as test_index
        FROM test_request_items tri
        JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
        WHERE tri.test_request_id = %s
        ORDER BY tri.tri_id
    """, (request_id,))
    
    test_items = cur.fetchall()
    
    if not test_items:
        return None
    
    # Get all samples for this request to find position
    cur.execute("SELECT sample_id FROM samples WHERE request_id = %s ORDER BY sample_id", (request_id,))
    all_samples = [row[0] for row in cur.fetchall()]
    
    # ✅ SAME LOGIC AS WORKSHEET: Calculate assigned test
    sample_position = all_samples.index(sample_id)
    assigned_test_index = sample_position % len(test_items)
    
    return test_items[assigned_test_index]


def get_project_quotation_items(project_id: int, cur):
    """Get invoiceable items - USING EXACT WORKSHEET LOGIC"""
    # Get all samples for this project
    cur.execute("""
        SELECT s.sample_id 
        FROM projects p
        JOIN test_requests tr ON p.project_id = tr.project_id
        JOIN samples s ON tr.test_request_id = s.request_id
        WHERE p.project_id = %s
        ORDER BY s.sample_id
    """, (project_id,))
    
    sample_ids = [row[0] for row in cur.fetchall()]
    
    filtered_items = []
    for sample_id in sample_ids:
        assigned_test = get_assigned_test_for_sample(sample_id, cur)
        if assigned_test:
            item_id, item_code, description, test_standard, unit_rate, quantity, tri_id, test_index = assigned_test
            
            # Get sample details
            cur.execute("SELECT sample_no, status FROM samples WHERE sample_id = %s", (sample_id,))
            sample_data = cur.fetchone()
            if sample_data:
                sample_no, sample_status = sample_data
            else:
                sample_no, sample_status = f"SMP-{sample_id}", "PENDING"
            
            # Get test request details
            cur.execute("""
                SELECT tr.test_request_id, tr.request_no 
                FROM test_requests tr 
                WHERE tr.test_request_id = (SELECT request_id FROM samples WHERE sample_id = %s)
            """, (sample_id,))
            request_data = cur.fetchone()
            if request_data:
                test_request_id, request_no = request_data
            else:
                test_request_id, request_no = None, "UNKNOWN"
            
            filtered_items.append((
                item_id, description, test_standard, unit_rate, 1,  # Quantity always 1 per sample
                test_request_id, request_no, sample_id, sample_no, sample_status
            ))
    
    return filtered_items

def get_invoice_complete(invoice_id: int, cur):
    """Get complete invoice details with items"""
    # Get invoice header
    cur.execute("""
        SELECT i.invoice_id, i.invoice_no, i.project_id, i.invoice_type, i.invoice_date,
               i.client_reference, i.lpo_reference, i.lpo_date, i.payment_terms,
               i.subtotal, i.vat, i.total, i.amount_in_words, i.services_description, 
               i.remarks, i.payment_status, i.paid_date,
               p.project_no, p.project_name, p.location,
               c.client_id, c.name, c.contact_person, c.email, c.address, c.phone
        FROM invoices i
        JOIN projects p ON i.project_id = p.project_id
        JOIN clients c ON p.client_id = c.client_id
        WHERE i.invoice_id = %s
    """, (invoice_id,))
    
    header = cur.fetchone()
    if not header:
        raise HTTPException(status_code=404, detail="Invoice not found")
    
    # Get invoice items - FIXED WITH BETTER SAMPLE DATA
    cur.execute("""
        SELECT 
            ii.item_id, 
            ii.description, 
            ii.test_standard, 
            ii.unit_rate, 
            ii.quantity, 
            ii.amount, 
            ii.sample_id, 
            s.sample_no,
            s.status as sample_status,
            tr.request_no,
            tr.test_request_id
        FROM invoice_items ii
        LEFT JOIN samples s ON ii.sample_id = s.sample_id
        LEFT JOIN test_requests tr ON ii.test_request_id = tr.test_request_id
        WHERE ii.invoice_id = %s
        ORDER BY ii.item_id
    """, (invoice_id,))
    
    items_data = cur.fetchall()
    items_list = []
    for item in items_data:
        items_list.append({
            "item_id": item[0],
            "description": item[1],
            "test_standard": item[2],
            "unit_rate": float(item[3]) if isinstance(item[3], Decimal) else item[3],
            "quantity": item[4],
            "amount": float(item[5]) if isinstance(item[5], Decimal) else item[5],
            "sample_id": item[6],
            "sample_no": item[7],
            "sample_status": item[8],
            "request_no": item[9],
            "test_request_id": item[10]
        })
    
    return {
        "invoice_id": header[0],
        "invoice_no": header[1],
        "project_id": header[2],
        "invoice_type": header[3],
        "invoice_date": header[4],
        "client_reference": header[5],
        "lpo_reference": header[6],
        "lpo_date": header[7],
        "payment_terms": header[8],
        "subtotal": float(header[9]) if isinstance(header[9], Decimal) else header[9],
        "vat": float(header[10]) if isinstance(header[10], Decimal) else header[10],
        "total": float(header[11]) if isinstance(header[11], Decimal) else header[11],
        "amount_in_words": header[12],
        "services_description": header[13],
        "remarks": header[14],
        "payment_status": header[15],
        "paid_date": header[16],
        "items": items_list,
        "project_details": {
            "project_no": header[17],
            "project_name": header[18],
            "location": header[19],
            "client_name": header[20],
            "client_contact": header[21],
            "client_email": header[22],
            "client_address": header[23],
            "client_phone": header[24]
        }
    }

# ----------------------------
# CREATE INVOICE - FIXED DATA TYPES AND QUERIES
# ----------------------------
@router.post("/", response_model=InvoiceOut)
def create_invoice(payload: InvoiceCreate):
    """
    Create a new invoice for a project.
    Group invoice items by description, test standard, and unit rate.
    """
    conn = get_connection()
    cur = conn.cursor()

    try:
        # ---------------------------------------------------
        # 1. Get project details with client info
        # ---------------------------------------------------
        cur.execute("""
            SELECT p.project_id, p.project_no, p.project_name, p.location, p.lpo_no, p.lpo_date,
                   c.client_id, c.name, c.contact_person, c.email, c.address, c.phone,
                   q.quotation_no
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            JOIN quotations q ON p.quotation_id = q.quotation_id
            WHERE p.project_id = %s
        """, (payload.project_id,))
        project_data = cur.fetchone()
        if not project_data:
            raise HTTPException(status_code=404, detail="Project not found")

        # ---------------------------------------------------
        # 2. Get invoiceable items from project
        # ---------------------------------------------------
        invoiceable_items = get_project_quotation_items(payload.project_id, cur)
        if not invoiceable_items:
            raise HTTPException(status_code=400, detail="No test items available for invoicing")

        # ---------------------------------------------------
        # 2a. Group invoiceable items by description, test standard, unit rate
        # ---------------------------------------------------
        from collections import defaultdict

        grouped_items = defaultdict(lambda: {
            "description": "",
            "test_standard": "",
            "unit_rate": 0,
            "quantity": 0,
            "sample_ids": []
        })

        for item in invoiceable_items:
            item_id, description, test_standard, unit_rate, quantity, test_request_id, request_no, sample_id, sample_no, sample_status = item
            key = (description, test_standard, unit_rate)
            grouped_items[key]["description"] = description
            grouped_items[key]["test_standard"] = test_standard
            grouped_items[key]["unit_rate"] = unit_rate
            grouped_items[key]["quantity"] += quantity
            grouped_items[key]["sample_ids"].append(sample_id)

        # Convert grouped items to a list
        final_items = []
        for (desc, std, rate), data in grouped_items.items():
            final_items.append((desc, std, rate, data["quantity"], data["sample_ids"]))

        # ---------------------------------------------------
        # 3. Generate invoice number
        # ---------------------------------------------------
        invoice_no = generate_invoice_no(cur, payload.invoice_type)

        # ---------------------------------------------------
        # 4. Calculate totals
        # ---------------------------------------------------
        subtotal = 0.0
        for item in final_items:
            desc, std, unit_rate, quantity, sample_ids = item
            unit_rate_float = float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate
            subtotal += unit_rate_float * quantity

        vat = subtotal * 0.05  # 5% VAT
        total = subtotal + vat
        amount_words = number_to_words(total)

        # ---------------------------------------------------
        # 5. LPO and payment terms
        # ---------------------------------------------------
        lpo_reference = payload.lpo_reference or project_data[4]
        lpo_date = payload.lpo_date or project_data[5]
        payment_terms = payload.payment_terms or "30 days"

        # ---------------------------------------------------
        # 6. Insert invoice header
        # ---------------------------------------------------
        cur.execute("""
            INSERT INTO invoices (
                invoice_no, project_id, invoice_type, invoice_date,
                client_reference, lpo_reference, lpo_date, payment_terms,
                subtotal, vat, total, amount_in_words, services_description, remarks
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING invoice_id
        """, (
            invoice_no,
            payload.project_id,
            payload.invoice_type,
            payload.invoice_date or date.today(),
            payload.client_reference,
            lpo_reference,
            lpo_date,
            payment_terms,
            subtotal,
            vat,
            total,
            amount_words,
            payload.services_description or f"Testing services for {project_data[2]}",
            payload.remarks
        ))
        invoice_id = cur.fetchone()[0]

        # ---------------------------------------------------
        # 7. Insert grouped invoice items
        # ---------------------------------------------------
        for item in final_items:
            description, test_standard, unit_rate, quantity, sample_ids = item
            unit_rate_float = float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate
            amount = unit_rate_float * quantity
            sample_id = sample_ids[0] if sample_ids else None  # representative sample

            cur.execute("""
                INSERT INTO invoice_items (
                    invoice_id, description, test_standard,
                    unit_rate, quantity, amount, sample_id
                )
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (
                invoice_id,
                description,
                test_standard,
                unit_rate_float,
                quantity,
                amount,
                sample_id
            ))

        # ---------------------------------------------------
        # 8. Commit transaction
        # ---------------------------------------------------
        conn.commit()

        # ---------------------------------------------------
        # 9. Return complete invoice
        # ---------------------------------------------------
        return get_invoice_complete(invoice_id, cur)

    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()


# ----------------------------
# LIST INVOICES - FIXED
# ----------------------------
@router.get("/", response_model=List[InvoiceOut])
def list_invoices(limit: int = 100, offset: int = 0):
    conn = get_connection()
    cur = conn.cursor()
# Add debug print in Excel generation function
    try:
        cur.execute("""
            SELECT invoice_id FROM invoices 
            ORDER BY invoice_id DESC 
            LIMIT %s OFFSET %s
        """, (limit, offset))
        
        invoice_ids = [row[0] for row in cur.fetchall()]
        invoices = []
        
        for inv_id in invoice_ids:
            invoices.append(get_invoice_complete(inv_id, cur))
        
        return invoices
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ----------------------------
# GET SINGLE INVOICE
# ----------------------------
@router.get("/{invoice_id}", response_model=InvoiceOut)
def get_invoice(invoice_id: int):
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        return get_invoice_complete(invoice_id, cur)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ----------------------------
# UPDATE PAYMENT STATUS
# ----------------------------
@router.post("/{invoice_id}/payment-status")
def update_payment_status(invoice_id: int, status: str, paid_date: Optional[date] = None):
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            UPDATE invoices 
            SET payment_status = %s, paid_date = %s
            WHERE invoice_id = %s
            RETURNING invoice_id
        """, (status, paid_date, invoice_id))
        
        if not cur.fetchone():
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        conn.commit()
        return {"message": "Payment status updated", "invoice_id": invoice_id, "status": status}
        
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ----------------------------
# GET PROJECT INVOICEABLE ITEMS - FIXED
# ----------------------------
@router.get("/projects/{project_id}/invoiceable-items")
def get_invoiceable_items(project_id: int):
    """Get all items that can be invoiced for a project - FIXED"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        items = get_project_quotation_items(project_id, cur)
        
        return {
            "project_id": project_id,
            "invoiceable_items": [
                {
                    "quotation_item_id": item[0],
                    "description": item[1],
                    "test_standard": item[2],
                    "unit_rate": float(item[3]) if isinstance(item[3], Decimal) else item[3],
                    "quantity": item[4],
                    "test_request_id": item[5],
                    "request_no": item[6],
                    "sample_id": item[7],
                    "sample_no": item[8],
                    "sample_status": item[9]
                }
                for item in items
            ]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ----------------------------
# GET INVOICE AS HTML TABLE
# ----------------------------
@router.get("/{invoice_id}/html-table", response_class=HTMLResponse)
def get_invoice_html_table(invoice_id: int):
    """Get invoice as full rendered HTML page"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        invoice_data = get_invoice_complete(invoice_id, cur)

        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Invoice {invoice_data['invoice_no']}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h2, h3 {{ color: #333; }}
                table {{ width: 100%; border-collapse: collapse; margin-bottom: 20px; }}
                th, td {{ padding: 8px; border: 1px solid #ddd; }}
                th {{ background-color: #f2f2f2; text-align: left; }}
                .right {{ text-align: right; }}
                .center {{ text-align: center; }}
            </style>
        </head>
        <body>
            <h2>INVOICE: {invoice_data['invoice_no']}</h2>

            <h3>Client Information</h3>
            <table>
                <tr><th>Client</th><td>{invoice_data['project_details']['client_name']}</td></tr>
                <tr><th>Contact</th><td>{invoice_data['project_details']['client_contact']}</td></tr>
                <tr><th>Email</th><td>{invoice_data['project_details']['client_email']}</td></tr>
                <tr><th>Phone</th><td>{invoice_data['project_details']['client_phone'] or 'N/A'}</td></tr>
            </table>

            <h3>Project Information</h3>
            <table>
                <tr><th>Project No</th><td>{invoice_data['project_details']['project_no']}</td></tr>
                <tr><th>Project Name</th><td>{invoice_data['project_details']['project_name']}</td></tr>
                <tr><th>Location</th><td>{invoice_data['project_details']['location']}</td></tr>
            </table>

            <h3>Invoice Items</h3>
            <table>
                <tr>
                    <th>#</th>
                    <th>Description</th>
                    <th>Test Standard</th>
                    <th class="right">Unit Rate</th>
                    <th class="center">Qty</th>
                    <th class="right">Amount</th>
                    <th>Sample No</th>
                    <th>Status</th>
                </tr>
        """

        # Add item rows
        for i, item in enumerate(invoice_data["items"], 1):
            html_content += f"""
                <tr>
                    <td>{i}</td>
                    <td>{item['description']}</td>
                    <td>{item['test_standard'] or 'N/A'}</td>
                    <td class="right">AED {item['unit_rate']:.2f}</td>
                    <td class="center">{item['quantity']}</td>
                    <td class="right">AED {item['amount']:.2f}</td>
                    <td>{item['sample_no'] or 'N/A'}</td>
                    <td>{item['sample_status']}</td>
                </tr>
            """

        # Financial summary
        html_content += f"""
            </table>

            <h3>Financial Summary</h3>
            <table>
                <tr><th>Subtotal</th><td class="right">AED {invoice_data['subtotal']:.2f}</td></tr>
                <tr><th>VAT (5%)</th><td class="right">AED {invoice_data['vat']:.2f}</td></tr>
                <tr><th>Total</th><td class="right"><b>AED {invoice_data['total']:.2f}</b></td></tr>
                <tr><th>Amount in Words</th><td>{invoice_data['amount_in_words']}</td></tr>
            </table>
        </body>
        </html>
        """

        return HTMLResponse(content=html_content)

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()








# INVOICES 

@router.get("/{invoice_id}/excel")
def generate_excel_invoice(invoice_id: int):
    """
    Generate Excel invoice using the template, insert rows dynamically,
    fill test items, report numbers, amounts, totals and save on server.
    """

    # Path to converted template (.xlsx)
    template_path = r"C:\Users\USER\my-react-app\public\templates\invoice.xlsx"

    if not os.path.exists(template_path):
        raise HTTPException(status_code=404, detail="Invoice template not found. Convert invoice.xls → .xlsx")

    conn = get_connection()
    cur = conn.cursor()

    try:
        # =====================================================
        # 1. Load full invoice from DB
        # =====================================================
        invoice = get_invoice_complete(invoice_id, cur)
        project_details = invoice.get("project_details", {})
        items = invoice.get("items", [])
        
        # DEBUG: Print what data we're getting
        print("=== DEBUG INVOICE DATA ===")
        print(f"Invoice: {invoice.get('invoice_no')}")
        print(f"Subtotal: {invoice.get('subtotal')}")
        print(f"VAT (5%): {invoice.get('vat')}")
        print(f"Total: {invoice.get('total')}")
        print(f"Number of items: {len(items)}")
        print("==========================")

        # =====================================================
        # 2. Load the Excel template
        # =====================================================
        wb = openpyxl.load_workbook(template_path, data_only=False)
        ws = wb.active

        # =====================================================
        # 3. Define Template Structure
        # =====================================================
        FIRST_ITEM_ROW = 18  # First item row in template (based on your image)
        LAST_TEMPLATE_ITEM_ROW = 34  # Last available item row in template
        TOTAL_ROW = 35  # Row with "GRAND TOTAL"
        VAT_ROW = 36    # Row with "VAT @ 5%"
        NET_TOTAL_ROW = 37  # Row with "NET TOTAL"
        AMOUNT_WORDS_ROW = 38  # Row with "United Arab Emirates Dirhams Only"
        
        # Calculate available template rows for items
        TEMPLATE_ITEM_ROWS = LAST_TEMPLATE_ITEM_ROW - FIRST_ITEM_ROW + 1  # 17 rows
        
        # =====================================================
        # 4. Fill Header Fields (NO CHANGE)
        # =====================================================
        ws["I4"] = invoice.get("invoice_no", " - ")
        
        # Invoice date
        invoice_date = invoice.get("invoice_date")
        if invoice_date:
            if isinstance(invoice_date, str):
                ws["I5"] = invoice_date
            else:
                ws["I5"] = invoice_date.strftime("%d-%b-%Y")
        else:
            ws["I5"] = " - "

        # Client Section
        ws["A5"] = project_details.get("client_name", " - ")
        ws["C10"] = project_details.get("client_contact", " - ")

        # Project details
        ws["C13"] = project_details.get("project_no", " - ")
        ws["C15"] = project_details.get("project_name", " - ")
        ws["C14"] = project_details.get("location", " - ")

        # LPO
        lpo_reference = invoice.get("lpo_reference", " - ")
        ws["C18"] = lpo_reference
        
        # LPO date
        lpo_date = invoice.get("lpo_date")
        if lpo_date:
            if isinstance(lpo_date, str):
                ws["I6"] = lpo_date
            else:
                ws["I6"] = lpo_date.strftime("%d-%b-%Y")
        else:
            ws["I6"] = " - "

        # Payment Terms
        ws["I8"] = invoice.get("payment_terms", " - ")

        # =====================================================
        # 5. Handle Dynamic Item Rows - FIXED LOGIC
        # =====================================================
        num_items = len(items)
        
        # Calculate where items will actually go
        if num_items <= TEMPLATE_ITEM_ROWS:
            # Case 1: Items fit within template rows (1-17 items)
            last_item_row = FIRST_ITEM_ROW + num_items - 1
            
            # Clear unused template rows
            for row in range(last_item_row + 1, LAST_TEMPLATE_ITEM_ROW + 1):
                for col in ['A', 'B', 'D', 'E', 'I', 'J', 'K']:
                    ws[f"{col}{row}"].value = None
        else:
            # Case 2: Need more rows than template provides
            rows_needed = num_items - TEMPLATE_ITEM_ROWS
            
            # Insert rows AFTER the template item area (after row 34)
            # This preserves the totals section position
            ws.insert_rows(LAST_TEMPLATE_ITEM_ROW + 1, amount=rows_needed)
            
            # Copy formatting from last template row (row 34) to new rows
            from copy import copy
            for i in range(rows_needed):
                new_row = LAST_TEMPLATE_ITEM_ROW + 1 + i
                # Copy formatting from row 34
                for col in range(1, 12):  # Columns A-K
                    source_cell = ws.cell(row=34, column=col)
                    target_cell = ws.cell(row=new_row, column=col)
                    target_cell.font = copy(source_cell.font)
                    target_cell.border = copy(source_cell.border)
                    target_cell.fill = copy(source_cell.fill)
                    target_cell.number_format = source_cell.number_format
                    target_cell.alignment = copy(source_cell.alignment)
            
            last_item_row = LAST_TEMPLATE_ITEM_ROW + rows_needed

        # =====================================================
        # 6. Fill Item Rows
        # =====================================================
        for index, item in enumerate(items):
            # Determine which row to use
            if index < TEMPLATE_ITEM_ROWS:
                # Use template rows (18-34)
                row = FIRST_ITEM_ROW + index
            else:
                # Use newly inserted rows
                extra_index = index - TEMPLATE_ITEM_ROWS
                row = LAST_TEMPLATE_ITEM_ROW + 1 + extra_index

            # Fetch report for this sample (if exists)
            cur.execute("""
                SELECT report_no, created_at
                FROM reports
                WHERE sample_id = %s
                ORDER BY report_id DESC LIMIT 1
            """, (item.get("sample_id"),))

            r = cur.fetchone()
            report_no = r[0] if r else " - "
            
            if r and r[1]:
                report_date = r[1].strftime("%d-%b-%Y") if hasattr(r[1], 'strftime') else str(r[1])
            else:
                report_date = " - "

            # Fill columns A–K
            ws[f"A{row}"] = report_no
            ws[f"B{row}"] = report_date
            ws[f"D{row}"] = item.get("description", " - ")
            ws[f"E{row}"] = item.get("test_standard", " - ")
            ws[f"I{row}"] = int(item.get("quantity", 0))
            ws[f"J{row}"] = float(item.get("unit_rate", 0))
            ws[f"K{row}"] = float(item.get("amount", 0))

        # =====================================================
        # 7. UPDATE FORMULAS - FIXED
        # =====================================================
        print(f"=== UPDATING EXCEL FORMULAS ===")
        print(f"First item row: {FIRST_ITEM_ROW}")
        print(f"Last item row: {last_item_row}")
        print(f"Total items: {num_items}")
        print("===============================")
        
        # IMPORTANT: Update the SUM formula to cover ALL item rows
        ws["K35"].value = f"=SUM(K{FIRST_ITEM_ROW}:K{last_item_row})"
        
        # K36 FORMULA: 5% of subtotal (already correct)
        ws["K36"].value = "=K35*0.05"
        
        # K37 FORMULA: Subtotal + VAT (already correct)
        ws["K37"].value = "=K35+K36"
        
        # Amount in words (static value)
        ws["B38"] = invoice.get("amount_in_words", " - ")
        
        # DEBUG: Verify formulas
        print(f"K35 formula set to: {ws['K35'].value}")
        print(f"K36 formula: {ws['K36'].value}")
        print(f"K37 formula: {ws['K37'].value}")
        
        # =====================================================
        # 8. Verify calculations match database
        # =====================================================
        # Calculate what Excel should show
        excel_subtotal = sum(item.get("amount", 0) for item in items)
        excel_vat = excel_subtotal * 0.05
        excel_total = excel_subtotal + excel_vat
        
        db_subtotal = float(invoice.get("subtotal", 0))
        db_vat = float(invoice.get("vat", 0))
        db_total = float(invoice.get("total", 0))
        
        print(f"=== VERIFICATION ===")
        print(f"Database values -> Subtotal: {db_subtotal}, VAT: {db_vat}, Total: {db_total}")
        print(f"Excel should show -> Subtotal: {excel_subtotal}, VAT: {excel_vat}, Total: {excel_total}")

        # =====================================================
        # 9. Save Final File on Server
        # =====================================================
        output_dir = r"C:\Users\USER\my-react-app\public\generated_invoices"
        os.makedirs(output_dir, exist_ok=True)

        # Create download filename
        invoice_no = invoice.get('invoice_no', 'invoice')
        project_name = project_details.get('project_name', '')
        lpo_reference = invoice.get("lpo_reference", "")
        
        # Replace slash with hyphen in invoice number for filename
        invoice_no_hyphen = invoice_no.replace('/', '-')
        
        # Clean up strings for filename
        import re
        
        def clean_filename(text):
            if not text:
                return ""
            text = re.sub(r'[\\/*?:"<>|]', '-', text)
            text = re.sub(r'\s+', '-', text)
            text = text.strip('- ')
            return text
        
        clean_project_name = clean_filename(project_name)
        
        has_lpo = lpo_reference and lpo_reference != " - " and lpo_reference != ""
        
        if has_lpo:
            clean_lpo_number = clean_filename(str(lpo_reference))
            download_filename = f"{invoice_no_hyphen}-{clean_project_name}-{clean_lpo_number}.xlsx"
        else:
            download_filename = f"{invoice_no_hyphen}-{clean_project_name}.xlsx"
        
        # Save file
        output_path = os.path.join(output_dir, f"{invoice_no_hyphen}.xlsx")
        wb.save(output_path)

        # =====================================================
        # 10. Return File for Download
        # =====================================================
        import urllib.parse
        encoded_filename = urllib.parse.quote(download_filename)
        
        return FileResponse(
            output_path,
            filename=download_filename,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f"attachment; filename*=UTF-8''{encoded_filename}; filename=\"{download_filename}\""
            }
        )

    except Exception as e:
        print("Error generating invoice:", e)
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        cur.close()
        conn.close()


# ----------------------------
# GET LATEST PROJECTS FOR INVOICE DROPDOWN - ENHANCED VERSION
# ----------------------------
@router.get("/projects/latest/")
def get_latest_projects():
    """
    Get the latest 10 projects with complete info for invoice creation
    Returns: Array of project objects with details
    """
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Enhanced query with more details
        cur.execute("""
            SELECT 
                p.project_id,
                p.project_name,
                p.project_no,
                c.name as client_name,
                p.location,
                q.quotation_no
            FROM projects p
            JOIN clients c ON p.client_id = c.client_id
            JOIN quotations q ON p.quotation_id = q.quotation_id
            ORDER BY p.project_id DESC
            LIMIT 10
        """)
        
        # Format response
        projects = []
        for row in cur.fetchall():
            project_id, project_name, project_no, client_name, location, quotation_no = row
            
            # Create display label for dropdown
            display_label = f"{project_no} - {project_name} ({client_name})"
            
            projects.append({
                "project_id": project_id,
                "project_name": display_label,  # Combined display text
                "project_no": project_no,
                "project_name_raw": project_name,  # Original project name
                "client_name": client_name,
                "location": location,
                "quotation_no": quotation_no,
                "value": project_id,  # For dropdown value
                "label": display_label  # For dropdown label
            })
        
        return projects
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

    














###############################################################
3. Projects
###############################################################

from fastapi import APIRouter, HTTPException, UploadFile, File
from fastapi.responses import FileResponse
from pydantic import BaseModel
from db import get_connection
from datetime import datetime
from typing import Optional, List
import os
import shutil

# FIXED: Remove duplicate prefix - just use prefix="/projects"
router = APIRouter(prefix="/projects", tags=["Projects"])

UPLOAD_DIR = "uploads/projects"
os.makedirs(UPLOAD_DIR, exist_ok=True)

# ------------------------------
# Pydantic Models
# ------------------------------
class ProjectCreate(BaseModel):
    quotation_id: int
    project_name: str
    location: str
    lpo_no: Optional[str] = None
    lpo_date: Optional[str] = None

class ProjectOut(BaseModel):
    project_id: int
    project_no: str
    quotation_id: int
    client_id: Optional[int]
    project_name: str
    location: str
    status: str
    lpo_no: Optional[str] = None
    lpo_date: Optional[str] = None
    quotation_no: Optional[str] = None
    client_name: Optional[str] = None

# ------------------------------
# LIST PROJECTS - FIXED
# ------------------------------
@router.get("/projects", response_model=List[ProjectOut])
def list_projects(limit: int = 100, offset: int = 0):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute(
            """
            SELECT p.project_id, p.project_no, p.quotation_id, p.client_id,
                   p.project_name, p.location, p.lpo_no, p.lpo_date,
                   p.division, p.status, p.created_at,
                   q.quotation_no, c.name as client_name
            FROM projects p
            LEFT JOIN quotations q ON p.quotation_id = q.quotation_id
            LEFT JOIN clients c ON p.client_id = c.client_id
            ORDER BY p.project_id DESC
            LIMIT %s OFFSET %s
            """,
            (limit, offset),
        )
        rows = cur.fetchall()

        return [
            {
                "project_id": r[0],
                "project_no": r[1],
                "quotation_id": r[2],
                "client_id": r[3],
                "project_name": r[4],
                "location": r[5],
                "lpo_no": r[6],
                "lpo_date": str(r[7]) if r[7] else None,  # Convert date to string
                "division": r[8],
                "status": r[9],
                "created_at": str(r[10]) if r[10] else None,
                "quotation_no": r[11],
                "client_name": r[12]
            }
            for r in rows
        ]

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()



################Project Creation#############
@router.post("/", response_model=ProjectOut)
def create_project(payload: ProjectCreate):
    """Create a new project from approved quotation"""
    conn = get_connection()
    cur = conn.cursor()

    try:
        # Get quotation details
        cur.execute("""
            SELECT q.quotation_id, e.client_id, q.division,
                   e.project_name as enquiry_project_name, 
                   e.location as enquiry_location
            FROM quotations q
            JOIN enquiries e ON q.enquiry_id = e.enquiry_id
            WHERE q.quotation_id = %s
        """, (payload.quotation_id,))
        row = cur.fetchone()

        if not row:
            raise HTTPException(404, "Quotation not found")

        quotation_id, client_id, division, enquiry_project_name, enquiry_location = row

        # Use provided project name/location or fall back to enquiry values
        project_name = payload.project_name if payload.project_name != "string" else enquiry_project_name
        location = payload.location if payload.location != "string" else enquiry_location

        # Get current year's last two digits
        year_last_two = datetime.utcnow().strftime("%y")
        
        # Find the latest project number to increment from 16732
        cur.execute("""
            SELECT project_no 
            FROM projects 
            WHERE project_no LIKE 'LP/%'
            ORDER BY project_id DESC 
            LIMIT 1
        """)
        
        last_project = cur.fetchone()
        if last_project:
            # Extract the middle number from format LP/16732/25/DXB
            last_number = int(last_project[0].split('/')[1])
            next_number = last_number + 1
        else:
            # Start from 16732 if no projects exist yet
            next_number = 16732
        
        # Format: LP/16732/25/DXB
        project_no = f"LP/{next_number}/{year_last_two}/DXB"

        # Parse LPO date if provided
        lpo_date = None
        if payload.lpo_date and payload.lpo_date != "string":
            lpo_date = datetime.strptime(payload.lpo_date, "%Y-%m-%d").date()

        # Insert the project
        cur.execute("""
            INSERT INTO projects (
                project_no, quotation_id, client_id, project_name,
                location, lpo_no, lpo_date, division, status
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, 'ACTIVE')
            RETURNING project_id
        """, (
            project_no,
            quotation_id,
            client_id,
            project_name,
            location,
            payload.lpo_no if payload.lpo_no != "string" else None,
            lpo_date,
            division
        ))

        project_id = cur.fetchone()[0]
        conn.commit()

        return {
            "project_id": project_id,
            "project_no": project_no,
            "quotation_id": quotation_id,
            "client_id": client_id,
            "project_name": project_name,
            "location": location,
            "status": "ACTIVE",
            "lpo_no": payload.lpo_no,
            "lpo_date": payload.lpo_date
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()
# ------------------------------
# GET PROJECT DETAILS
# ------------------------------
@router.get("/{project_id}", summary="Get Project Details")
def get_project_details(project_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            SELECT p.project_id, p.project_no, p.quotation_id, p.client_id,
                   p.project_name, p.location, p.lpo_no, p.lpo_date,
                   p.lpo_file, p.division, p.status, p.created_at,
                   q.quotation_no, c.name as client_name
            FROM projects p
            LEFT JOIN quotations q ON p.quotation_id = q.quotation_id
            LEFT JOIN clients c ON p.client_id = c.client_id
            WHERE p.project_id = %s
        """, (project_id,))

        row = cur.fetchone()

        if not row:
            raise HTTPException(404, "Project not found")

        return {
            "project_id": row[0],
            "project_no": row[1],
            "quotation_id": row[2],
            "client_id": row[3],
            "project_name": row[4],
            "location": row[5],
            "lpo_no": row[6],
            "lpo_date": str(row[7]) if row[7] else None,
            "lpo_file": row[8],
            "division": row[9],
            "status": row[10],
            "created_at": str(row[11]) if row[11] else None,
            "quotation_no": row[12],
            "client_name": row[13]
        }

    except Exception as e:
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()

# ------------------------------
# UPDATE PROJECT
# ------------------------------
@router.put("/{project_id}", summary="Update Project")
def update_project(project_id: int, payload: ProjectCreate):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("SELECT project_id FROM projects WHERE project_id = %s", (project_id,))
        if cur.fetchone() is None:
            raise HTTPException(404, "Project not found")

        lpo_date = None
        if payload.lpo_date and payload.lpo_date != "string":
            lpo_date = datetime.strptime(payload.lpo_date, "%Y-%m-%d").date()

        cur.execute("""
            UPDATE projects 
            SET project_name = %s, location = %s, lpo_no = %s, lpo_date = %s
            WHERE project_id = %s
            RETURNING project_id, project_no
        """, (
            payload.project_name,
            payload.location,
            payload.lpo_no if payload.lpo_no != "string" else None,
            lpo_date,
            project_id
        ))

        result = cur.fetchone()
        conn.commit()

        return {
            "message": "Project updated successfully",
            "project_id": result[0],
            "project_no": result[1]
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()

# ------------------------------
# UPLOAD LPO FILE
# ------------------------------
@router.post("/{project_id}/upload-lpo")
def upload_lpo_file(project_id: int, file: UploadFile = File(...)):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("SELECT project_id FROM projects WHERE project_id = %s", (project_id,))
        if cur.fetchone() is None:
            raise HTTPException(404, "Project not found")

        extension = file.filename.split(".")[-1]
        filename = f"LPO_{project_id}.{extension}"
        filepath = os.path.join(UPLOAD_DIR, filename)

        with open(filepath, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        cur.execute("""
            UPDATE projects 
            SET lpo_file = %s 
            WHERE project_id = %s
        """, (filename, project_id))

        conn.commit()

        return {
            "message": "LPO uploaded successfully",
            "file_name": filename,
            "path": filepath
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()

# ------------------------------
# DOWNLOAD LPO FILE
# ------------------------------
@router.get("/{project_id}/download-lpo")
def download_lpo(project_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("SELECT lpo_file FROM projects WHERE project_id = %s", (project_id,))
        row = cur.fetchone()

        if not row or not row[0]:
            raise HTTPException(404, "LPO file not found")

        filename = row[0]
        filepath = os.path.join(UPLOAD_DIR, filename)

        if not os.path.exists(filepath):
            raise HTTPException(404, "LPO file not found on server")

        return FileResponse(
            path=filepath,
            filename=filename,
            media_type='application/octet-stream'
        )

    except Exception as e:
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()

###############################################################
4. Quotations
###############################################################
# quotations.py
import io
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime
from db import get_connection
from fastapi.responses import StreamingResponse
from template_processor import QuotationTemplateProcessor

template_processor = QuotationTemplateProcessor("templates/GEO.docx")

router = APIRouter(prefix="/quotations", tags=["3. Quotations"])

VAT_RATE = 0.05


# ============================================================
# Pydantic Models
# ============================================================

class QuotationCreate(BaseModel):
    enquiry_id: int
    division: str
    payment_terms: Optional[str] = None
    prepared_under: Optional[str] = None  # Add this line
    validity_days: Optional[int] = 30


class QuotationItemCreate(BaseModel):
    description: str
    test_standard: Optional[str] = None
    unit_rate: float
    quantity: int


class QuotationItemFromCatalog(BaseModel):
    catalog_id: int
    quantity: int


# ============================================================
# Generate Quotation Number with New Format
# ============================================================

def _generate_quotation_no(cur, division, prepared_under):
    """Generate quotation number in format: QG-AR-001-25"""
    
    # Map division to prefix
    division_prefix = {
        'MAT': 'QL', 'GEO': 'QG', 'NDT': 'QL', 'CHM': 'QL',
        'BIO': 'QL', 'ENV': 'QL', 'SPJ': 'QL', 'SRV': 'QS'
    }
    
    # Map prepared_under to initials
    prepared_initials = {
        'AR': 'AR',  # Abdul Razak
        'AS': 'AS'   # Afroz Shaikh
    }
    
    # Get prefix (e.g., QG for GEO)
    prefix = division_prefix.get(division, 'QL')
    
    # Get initials (e.g., AR for Abdul Razak)
    initials = prepared_initials.get(prepared_under, 'XX')
    
    # Get current year (last 2 digits)
    year = datetime.now().strftime('%y')
    
    # Get next sequence number for this division+initials+year combination
    cur.execute("""
        SELECT COUNT(*) FROM quotations 
        WHERE division = %s 
        AND prepared_under = %s
        AND EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM NOW())
    """, (division, prepared_under))
    
    count = cur.fetchone()[0] + 1  # Start from 1
    
    # Format: QG-AR-001-25
    quotation_no = f"{prefix}-{initials}-{count:03d}-{year}"
    
    return quotation_no

# ============================================================
# 1️⃣ CREATE QUOTATION (Updated)
# ============================================================

@router.post("/", summary="Create Quotation")
def create_quotation(payload: QuotationCreate):
    conn = get_connection()
    cur = conn.cursor()

    try:
        # Validate enquiry exists
        cur.execute("SELECT enquiry_id FROM enquiries WHERE enquiry_id = %s", (payload.enquiry_id,))
        if cur.fetchone() is None:
            raise HTTPException(404, "Enquiry not found")
        
        # Validate division and prepared_under exist
        if not payload.division or not payload.prepared_under:
            raise HTTPException(400, "Division and prepared_under are required")

        # Generate new quotation number
        quotation_no = _generate_quotation_no(cur, payload.division, payload.prepared_under)
        revision = 1

        # Check if quotation number already exists (unlikely but safe)
        cur.execute("SELECT quotation_id FROM quotations WHERE quotation_no = %s", (quotation_no,))
        if cur.fetchone():
            # If exists, increment sequence
            quotation_no = _increment_quotation_no(cur, quotation_no)

        # Insert quotation with new format
        cur.execute("""
            INSERT INTO quotations (
                quotation_no, enquiry_id, division, revision,
                payment_terms, prepared_under, validity_days, status,
                total_amount, vat, grand_total, created_at
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, 'DRAFT', 0, 0, 0, NOW())
            RETURNING quotation_id
        """, (
            quotation_no, payload.enquiry_id, payload.division,
            revision, payload.payment_terms, payload.prepared_under,
            payload.validity_days
        ))

        qid = cur.fetchone()[0]
        conn.commit()

        return {
            "message": "Quotation created",
            "quotation_id": qid,
            "quotation_no": quotation_no
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()


# Helper function to increment if duplicate
def _increment_quotation_no(cur, quotation_no):
    """Increment the sequence number if quotation_no already exists"""
    parts = quotation_no.split('-')
    if len(parts) == 4:
        try:
            seq_num = int(parts[2])
            new_seq = seq_num + 1
            return f"{parts[0]}-{parts[1]}-{new_seq:03d}-{parts[3]}"
        except:
            pass
    return quotation_no


# ============================================================
# 2️⃣ ADD ITEM FROM PRICE CATALOG (AUTO-FILL)
# ============================================================

@router.post("/{quotation_id}/items/from-catalog", summary="Add Item From Price Catalog")
def add_item_from_catalog(quotation_id: int, payload: QuotationItemFromCatalog):
    conn = get_connection()
    cur = conn.cursor()

    try:
        # Validate quotation exists
        cur.execute("SELECT quotation_id FROM quotations WHERE quotation_id = %s", (quotation_id,))
        if cur.fetchone() is None:
            raise HTTPException(404, "Quotation not found")

        # Fetch catalog item
        cur.execute("""
            SELECT code, description, test_standard, unit_rate
            FROM price_catalog
            WHERE catalog_id = %s
        """, (payload.catalog_id,))
        catalog = cur.fetchone()

        if catalog is None:
            raise HTTPException(404, "Catalog item not found")

        code, description, test_standard, unit_rate = catalog

        if payload.quantity <= 0:
            raise HTTPException(400, "Quantity must be greater than zero")

        # Insert item
        cur.execute("""
            INSERT INTO quotation_items
                (quotation_id, item_code, description, test_standard, unit_rate, quantity)
            VALUES (%s, %s, %s, %s, %s, %s)
            RETURNING item_id
        """, (
            quotation_id, code, description, test_standard, unit_rate, payload.quantity
        ))

        item_id = cur.fetchone()[0]

        # Recalculate totals
        cur.execute("""
            UPDATE quotations
            SET total_amount = COALESCE(sub.total, 0),
                vat = COALESCE(sub.total, 0) * %s,
                grand_total = COALESCE(sub.total, 0) * (1 + %s)
            FROM (
                SELECT SUM(amount) AS total
                FROM quotation_items
                WHERE quotation_id = %s
            ) sub
            WHERE quotation_id = %s
            RETURNING total_amount, vat, grand_total
        """, (VAT_RATE, VAT_RATE, quotation_id, quotation_id))

        totals = cur.fetchone()
        conn.commit()

        return {
            "message": "Item added from catalog",
            "item_id": item_id,
            "quotation_id": quotation_id,
            "totals": {
                "total_amount": float(totals[0]),
                "vat": float(totals[1]),
                "grand_total": float(totals[2]),
            },
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# ============================================================
# 3️⃣ ADD CUSTOM ITEM TO QUOTATION (MANUAL ENTRY)
# ============================================================

@router.post("/{quotation_id}/items", summary="Add Custom Item to Quotation")
def add_item(quotation_id: int, item: QuotationItemCreate):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("SELECT quotation_id FROM quotations WHERE quotation_id = %s", (quotation_id,))
        if cur.fetchone() is None:
            raise HTTPException(404, "Quotation not found")

        if item.unit_rate < 0 or item.quantity <= 0:
            raise HTTPException(400, "Invalid unit_rate or quantity")

        # Insert manual item
        cur.execute("""
            INSERT INTO quotation_items (quotation_id, description, test_standard, unit_rate, quantity)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING item_id
        """, (quotation_id, item.description, item.test_standard, item.unit_rate, item.quantity))

        item_id = cur.fetchone()[0]

        # Recalculate totals
        cur.execute("""
            UPDATE quotations
            SET total_amount = COALESCE(sub.total, 0),
                vat = COALESCE(sub.total, 0) * %s,
                grand_total = COALESCE(sub.total, 0) * (1 + %s)
            FROM (
                SELECT SUM(amount) AS total
                FROM quotation_items
                WHERE quotation_id = %s
            ) sub
            WHERE quotations.quotation_id = %s
            RETURNING total_amount, vat, grand_total
        """, (VAT_RATE, VAT_RATE, quotation_id, quotation_id))

        totals = cur.fetchone()
        conn.commit()

        return {
            "message": "Item added",
            "item_id": item_id,
            "quotation_id": quotation_id,
            "totals": {
                "total_amount": float(totals[0]),
                "vat": float(totals[1]),
                "grand_total": float(totals[2]),
            },
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# ============================================================
# 4️⃣ SEND QUOTATION
# ============================================================

@router.post("/{quotation_id}/send", summary="Send Quotation to Client")
def send_quotation(quotation_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            UPDATE quotations
            SET status = 'SENT', approved_at = NULL
            WHERE quotation_id = %s
            RETURNING quotation_id
        """, (quotation_id,))

        if cur.fetchone() is None:
            raise HTTPException(404, "Quotation not found")

        conn.commit()
        return {"message": "Quotation sent", "quotation_id": quotation_id}

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# ============================================================
# 5️⃣ APPROVE QUOTATION
# ============================================================

@router.post("/{quotation_id}/approve", summary="Approve Quotation")
def approve_quotation(quotation_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            UPDATE quotations
            SET status = 'APPROVED', approved_at = NOW()
            WHERE quotation_id = %s
            RETURNING quotation_id, enquiry_id
        """, (quotation_id,))

        row = cur.fetchone()

        if row is None:
            raise HTTPException(404, "Quotation not found")

        conn.commit()

        return {
            "message": "Quotation approved",
            "quotation_id": row[0],
            "enquiry_id": row[1]
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# ============================================================
# 6️⃣ REJECT QUOTATION
# ============================================================

@router.post("/{quotation_id}/reject", summary="Reject Quotation")
def reject_quotation(quotation_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            UPDATE quotations
            SET status = 'REJECTED'
            WHERE quotation_id = %s
            RETURNING quotation_id
        """, (quotation_id,))

        if cur.fetchone() is None:
            raise HTTPException(404, "Quotation not found")

        conn.commit()

        return {"message": "Quotation rejected", "quotation_id": quotation_id}

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# ============================================================
# 7️⃣ CLARIFICATION REQUEST
# ============================================================

@router.post("/{quotation_id}/clarification", summary="Request Clarification")
def clarification_request(quotation_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            UPDATE quotations
            SET status = 'CLARIFICATION'
            WHERE quotation_id = %s
            RETURNING quotation_id
        """, (quotation_id,))

        if cur.fetchone() is None:
            raise HTTPException(404, "Quotation not found")

        conn.commit()

        return {"message": "Clarification added", "quotation_id": quotation_id}

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# ============================================================
# 8️⃣ CREATE REVISION (Updated for new format)
# ============================================================

@router.post("/{quotation_id}/revision", summary="Create Revision of Quotation")
def create_revision(quotation_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        # Get original quotation
        cur.execute("""
            SELECT quotation_no, enquiry_id, division, payment_terms,
                   prepared_under, validity_days, revision
            FROM quotations
            WHERE quotation_id = %s
        """, (quotation_id,))

        orig = cur.fetchone()

        if orig is None:
            raise HTTPException(404, "Quotation not found")

        (orig_no, enquiry_id, division, payment_terms, 
         prepared_under, validity_days, orig_rev) = orig
        
        new_rev = orig_rev + 1
        
        # Generate new quotation number for revision
        # For revisions, we keep the same base but increment revision
        parts = orig_no.split('-')
        if len(parts) == 4:
            # Format: QG-AR-001-25 -> QG-AR-001-25-V2
            new_q_no = f"{orig_no}-V{new_rev}"
        else:
            # Handle existing revisions: QG-AR-001-25-V1 -> QG-AR-001-25-V2
            base = orig_no.rsplit('-V', 1)[0]
            new_q_no = f"{base}-V{new_rev}"

        # Insert new revision
        cur.execute("""
            INSERT INTO quotations (
                quotation_no, enquiry_id, division, revision,
                payment_terms, prepared_under, validity_days, status,
                total_amount, vat, grand_total, created_at
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, 'DRAFT', 0, 0, 0, NOW())
            RETURNING quotation_id
        """, (
            new_q_no, enquiry_id, division, new_rev, 
            payment_terms, prepared_under, validity_days
        ))

        new_qid = cur.fetchone()[0]

        # Copy items
        cur.execute("""
            INSERT INTO quotation_items (quotation_id, description, test_standard, unit_rate, quantity)
            SELECT %s, description, test_standard, unit_rate, quantity
            FROM quotation_items
            WHERE quotation_id = %s
        """, (new_qid, quotation_id))

        # Recalculate totals
        cur.execute("""
            UPDATE quotations
            SET total_amount = sub.total,
                vat = sub.total * %s,
                grand_total = sub.total * (1 + %s)
            FROM (
                SELECT SUM(amount) AS total
                FROM quotation_items
                WHERE quotation_id = %s
            ) sub
            WHERE quotation_id = %s
            RETURNING total_amount, vat, grand_total
        """, (VAT_RATE, VAT_RATE, new_qid, new_qid))

        totals = cur.fetchone()
        conn.commit()

        return {
            "message": "Revision created",
            "new_quotation_id": new_qid,
            "new_quotation_no": new_q_no,
            "totals": {
                "total_amount": float(totals[0]),
                "vat": float(totals[1]),
                "grand_total": float(totals[2]),
            }
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()


# ============================================================
# 9️⃣ LIST QUOTATIONS
# ============================================================

@router.get("/", summary="List All Quotations")
def list_quotations(limit: int = 100, offset: int = 0):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            SELECT q.quotation_id, q.quotation_no, q.division, q.revision,
                   q.status, q.total_amount, q.grand_total,
                   e.enquiry_ref, c.client_id, c.name
            FROM quotations q
            LEFT JOIN enquiries e ON q.enquiry_id = e.enquiry_id
            LEFT JOIN clients c ON e.client_id = c.client_id
            ORDER BY q.quotation_id DESC
            LIMIT %s OFFSET %s
        """, (limit, offset))

        rows = cur.fetchall()

        return [
            {
                "quotation_id": r[0],
                "quotation_no": r[1],
                "division": r[2],
                "revision": r[3],
                "status": r[4],
                "total_amount": float(r[5] or 0),
                "grand_total": float(r[6] or 0),
                "enquiry_ref": r[7],
                "client_id": r[8],
                "client_name": r[9]
            }
            for r in rows
        ]

    except Exception as e:
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# quotations.py - Update the download_quotation function

@router.get("/{quotation_id}/download", summary="Download Quotation as Word Document")
def download_quotation(quotation_id: int):
    """Generate and download quotation from template"""
    conn = get_connection()
    cur = conn.cursor()

    try:
        # Fetch quotation details including division
        cur.execute("""
            SELECT 
                q.quotation_id, q.quotation_no, q.division, q.revision,
                q.status, q.total_amount, q.vat, q.grand_total,
                q.payment_terms, q.validity_days, q.created_at,
                e.enquiry_ref, e.project_name, e.location, 
                e.enquiry_date,
                c.client_id, c.name, c.contact_person, c.email,
                c.phone, c.address
            FROM quotations q
            LEFT JOIN enquiries e ON q.enquiry_id = e.enquiry_id
            LEFT JOIN clients c ON e.client_id = c.client_id
            WHERE q.quotation_id = %s
        """, (quotation_id,))

        row = cur.fetchone()

        if not row:
            raise HTTPException(404, "Quotation not found")
        
        division = row[2]  # Get division from query result

        # Fetch items
        cur.execute("""
            SELECT 
                description, test_standard, unit_rate, quantity,
                COALESCE(amount, unit_rate * quantity) as amount, 
                COALESCE(unit, 'No.') as unit
            FROM quotation_items
            WHERE quotation_id = %s
            ORDER BY item_id
        """, (quotation_id,))

        items = [
            {
                "description": r[0],
                "test_standard": r[1],
                "unit_rate": float(r[2]),
                "quantity": r[3],
                "amount": float(r[4]),
                "unit": r[5]
            }
            for r in cur.fetchall()
        ]

        # Prepare quotation data
        quotation_data = {
            "quotation_id": row[0],
            "quotation_no": row[1],
            "division": division,  # This is the division
            "revision": row[3],
            "status": row[4],
            "total_amount": float(row[5] or 0),
            "vat": float(row[6] or 0),
            "grand_total": float(row[7] or 0),
            "payment_terms": row[8],
            "validity_days": row[9],
            "created_at": row[10],
            "enquiry_ref": row[11],
            "project_name": row[12] or "Proposed Project",
            "location": row[13] or "Dubai, UAE",
            "enquiry_date": row[14]
        }

        # Prepare client data
        client_data = {
            "client_id": row[15],
            "name": row[16] or "",
            "contact_person": row[17] or "",
            "email": row[18] or "",
            "phone": row[19] or "",
            "address": row[20] or ""
        }

        # Choose template based on division
        template_map = {
            'GEO': 'templates/GEO.docx',
            'MAT': 'templates/MAT.docx',
            'SRV': 'templates/SRV.docx',
            'NDT': 'templates/NDT.docx',
            'CHM': 'templates/CHM.docx',
            'BIO': 'templates/BIO.docx',
            'ENV': 'templates/ENV.docx',
            'SPJ': 'templates/SPJ.docx'
        }
        
        template_path = template_map.get(division, 'templates/GEO.docx')
        
        # Create template processor with the selected template
        template_processor = QuotationTemplateProcessor(template_path)

        # Generate document from template
        doc_bytes = template_processor.process_quotation(quotation_data, client_data, items)

        # Create response
        filename = f"Quotation_{quotation_data['quotation_no']}_{division}.docx"
        
        return StreamingResponse(
            io.BytesIO(doc_bytes.getvalue()),
            media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )

    except FileNotFoundError as e:
        raise HTTPException(500, f"Template file not found: {str(e)}")
    except Exception as e:
        raise HTTPException(500, f"Failed to generate document: {str(e)}")
    finally:
        cur.close()
        conn.close()
# ============================================================
# 🔟 QUOTATION DETAILS
# ============================================================

@router.get("/{quotation_id}", summary="Get Quotation Details")
def quotation_details(quotation_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            SELECT q.quotation_id, q.quotation_no, q.division, q.revision,
                   q.status, q.total_amount, q.vat, q.grand_total,
                   q.payment_terms, q.validity_days,
                   e.enquiry_ref,
                   c.client_id, c.name, c.contact_person, c.email,
                   e.project_name, e.location
            FROM quotations q
            LEFT JOIN enquiries e ON q.enquiry_id = e.enquiry_id
            LEFT JOIN clients c ON e.client_id = c.client_id
            WHERE q.quotation_id = %s
        """, (quotation_id,))

        row = cur.fetchone()

        if not row:
            raise HTTPException(404, "Quotation not found")

        # Fetch items
        cur.execute("""
            SELECT description, test_standard, unit_rate, quantity, amount
            FROM quotation_items
            WHERE quotation_id = %s
            ORDER BY item_id
        """, (quotation_id,))

        items = [
            {
                "description": r[0],
                "test_standard": r[1],
                "unit_rate": float(r[2]),
                "quantity": r[3],
                "amount": float(r[4])
            }
            for r in cur.fetchall()
        ]

        return {
            "quotation_id": row[0],
            "quotation_no": row[1],
            "division": row[2],
            "revision": row[3],
            "status": row[4],
            "total_amount": float(row[5] or 0),
            "vat": float(row[6] or 0),
            "grand_total": float(row[7] or 0),
            "payment_terms": row[8],
            "validity_days": row[9],
            "enquiry_ref": row[10],
            "client_id": row[11],
            "client_name": row[12],
            "client_contact": row[13],
            "client_email": row[14],
            "project_name": row[15],
            "location": row[16],
            "items": items
        }

    except Exception as e:
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# ============================================================
# PRICE CATALOG ENDPOINT (ADD THIS TO YOUR quotations.py)
# ============================================================

@router.get("/price-catalog/", summary="Get Active Price Catalog Items")
def get_price_catalog():
    """Get all active items from price catalog for dropdown selection"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT catalog_id, code, description, test_standard, unit_rate, unit, active
            FROM price_catalog 
            WHERE active = true
            ORDER BY code
        """)
        
        items = cur.fetchall()
        
        return [
            {
                "catalog_id": item[0],
                "code": item[1],
                "description": item[2],
                "test_standard": item[3],
                "unit_rate": float(item[4]),
                "unit": item[5],
                "active": item[6]
            }
            for item in items
        ]
        
    except Exception as e:
        raise HTTPException(500, f"Failed to fetch price catalog: {str(e)}")
    finally:
        cur.close()
        conn.close()



###############################################################
5. Reports
###############################################################

# reports.py - UPDATED VERSION FOR COMBINED REPORTS PER TEST TYPE
from fastapi import APIRouter, HTTPException, UploadFile, File, Form
from fastapi.responses import FileResponse
from typing import Optional, List, Dict, Any
from datetime import datetime
from db import get_connection
import os
import shutil
import secrets

router = APIRouter(prefix="/reports", tags=["Reports"])

REPORTS_UPLOAD_DIR = "uploads/reports"
os.makedirs(REPORTS_UPLOAD_DIR, exist_ok=True)

# ---------------------------
# NEW: Helper to get test type distribution for a request
# ---------------------------
# ---------------------------
# FIXED: Helper to get test type distribution for a request
# ---------------------------
def get_test_distribution_for_request(request_id: int, cur):
    """Get how samples are distributed across test types"""
    cur.execute("""
        -- Get all test items for this request with their quantities
        SELECT tri.tri_id, tri.quotation_item_id, tri.quantity,
               qi.item_code, qi.description
        FROM test_request_items tri
        JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
        WHERE tri.test_request_id = %s
        ORDER BY tri.tri_id
    """, (request_id,))
    
    test_items = cur.fetchall()
    
    # Get all samples for this request
    cur.execute("""
        SELECT sample_id, sample_no
        FROM samples 
        WHERE request_id = %s
        ORDER BY sample_id
    """, (request_id,))
    
    samples = cur.fetchall()
    
    # Map each sample to its test type
    sample_to_test_map = {}
    test_distribution = {}
    
    sample_index = 0
    for test_item in test_items:
        # Safely unpack with default values
        tri_id = test_item[0] if len(test_item) > 0 else None
        item_id = test_item[1] if len(test_item) > 1 else None
        quantity = test_item[2] if len(test_item) > 2 else 1
        item_code = test_item[3] if len(test_item) > 3 else "UNKNOWN"
        description = test_item[4] if len(test_item) > 4 else "Unknown Test"
        
        for i in range(quantity):
            if sample_index < len(samples):
                sample = samples[sample_index]
                sample_id = sample[0] if len(sample) > 0 else None
                sample_no = sample[1] if len(sample) > 1 else f"GS-UNKNOWN-{sample_index}"
                
                if sample_id:  # Only map if we have a valid sample_id
                    sample_to_test_map[sample_id] = {
                        "tri_id": tri_id,
                        "item_id": item_id,
                        "item_code": item_code,
                        "test_name": description,
                        "quantity": quantity
                    }
                    
                    # Track test distribution
                    if item_code not in test_distribution:
                        test_distribution[item_code] = {
                            "test_name": description,
                            "item_code": item_code,
                            "samples": [],
                            "total_quantity": quantity,
                            "sample_count": 0
                        }
                    
                    test_distribution[item_code]["samples"].append({
                        "sample_id": sample_id,
                        "sample_no": sample_no
                    })
                    test_distribution[item_code]["sample_count"] += 1
                
                sample_index += 1
    
    return sample_to_test_map, test_distribution

# ---------------------------
# UPDATED: Report number generator with better uniqueness
# ---------------------------
# ---------------------------
# FIXED: Report number generator - simplified version
# ---------------------------
def generate_report_no(cur):
    """Generate unique report number: GR - DDMMYY - XXX"""
    today = datetime.now()
    date_str = today.strftime("%d%m%y")  # DDMMYY format
    
    try:
        # Simple approach: count reports created today
        cur.execute("""
            SELECT COUNT(*) 
            FROM reports 
            WHERE DATE(created_at) = CURRENT_DATE
        """)
        count = cur.fetchone()[0]
        
        # Generate sequence number
        seq_num = count + 1
        report_seq = f"{seq_num:03d}"
        
        report_no = f"GR - {date_str} - {report_seq}"
        
        # Double-check for uniqueness (in case of race condition)
        cur.execute("SELECT COUNT(*) FROM reports WHERE report_no = %s", (report_no,))
        if cur.fetchone()[0] > 0:
            # Add timestamp if duplicate
            timestamp = int(datetime.now().timestamp() % 1000)
            report_no = f"GR - {date_str} - {report_seq}-{timestamp}"
        
        return report_no
        
    except Exception as e:
        # Fallback: use timestamp-based number
        timestamp = int(datetime.now().timestamp() % 1000000)
        return f"GR - {date_str} - {timestamp:06d}"

# ---------------------------
# 1. Search Sample by Sample No (GS format) - UPDATED
# ---------------------------
@router.get("/samples/search")
def search_sample_by_no(sample_no: str):
    """Search for sample by sample number (GS format)"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT s.sample_id, s.sample_no, s.request_id, s.status,
                   tr.request_no
            FROM samples s
            JOIN test_requests tr ON s.request_id = tr.test_request_id
            WHERE LOWER(s.sample_no) LIKE LOWER(%s)
            ORDER BY s.created_at DESC
            LIMIT 10
        """, (f"%{sample_no}%",))
        
        samples = cur.fetchall()
        if not samples:
            raise HTTPException(404, "No samples found with that sample number")
        
        result = []
        for sample in samples:
            sample_id, sample_no, request_id, status, request_no = sample
            
            # Get test distribution for this request
            sample_to_test_map, test_distribution = get_test_distribution_for_request(request_id, cur)
            
            # Get which test this sample belongs to
            test_info = sample_to_test_map.get(sample_id, {})
            
            result.append({
                "sample_id": sample_id,
                "sample_no": sample_no,
                "request_id": request_id,
                "status": status,
                "request_no": request_no,
                "test_name": test_info.get("test_name", "Unknown"),
                "item_code": test_info.get("item_code", "Unknown")
            })
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(500, f"Error searching samples: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 2. Get Latest 10 Sample Numbers - UPDATED
# ---------------------------
@router.get("/samples/latest")
def get_latest_samples():
    """Get latest 10 sample numbers for dropdown with test info"""
    conn = get_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            SELECT s.sample_id, s.sample_no, s.request_id, s.status,
                   tr.request_no
            FROM samples s
            JOIN test_requests tr ON s.request_id = tr.test_request_id
            WHERE s.sample_no LIKE 'GS%'
            ORDER BY s.sample_id DESC
            LIMIT 10
        """)
        
        samples = cur.fetchall()
        result = []
        
        for sample in samples:
            sample_id, sample_no, request_id, status, request_no = sample
            
            # Get test distribution
            sample_to_test_map, _ = get_test_distribution_for_request(request_id, cur)
            test_info = sample_to_test_map.get(sample_id, {})
            
            result.append({
                "sample_id": sample_id,
                "sample_no": sample_no,
                "request_no": request_no,
                "test_name": test_info.get("test_name", "Unknown"),
                "item_code": test_info.get("item_code", "Unknown"),
                "status": status
            })
        
        return result
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")
    finally:
        cur.close()
        if conn is not None:
            conn.close()

# ---------------------------
# 3. Get Sample Test Info & Check for Existing Reports - COMPLETELY REWRITTEN
# ---------------------------
@router.get("/samples/by-number/{sample_no}")
def get_sample_template_info_by_no(sample_no: str):
    """Check which test this sample is for, if template exists, and if report already created"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # First, get the sample by sample_no
        cur.execute("""
            SELECT sample_id, request_id 
            FROM samples 
            WHERE sample_no = %s
        """, (sample_no,))
        
        sample_info = cur.fetchone()
        if not sample_info:
            raise HTTPException(404, f"Sample not found: {sample_no}")
        
        sample_id, request_id = sample_info
        
        # Get test distribution for this request
        sample_to_test_map, test_distribution = get_test_distribution_for_request(request_id, cur)
        
        # Get which test this sample belongs to
        test_info = sample_to_test_map.get(sample_id)
        if not test_info:
            raise HTTPException(400, f"Cannot determine test type for sample {sample_no}")
        
        item_code = test_info["item_code"]
        test_name = test_info["test_name"]
        tri_id = test_info["tri_id"]
        
        # Get ALL samples for this test type
        test_samples = []
        for sample_id_key, test_data in sample_to_test_map.items():
            if test_data["item_code"] == item_code:
                cur.execute("""
                    SELECT sample_no FROM samples WHERE sample_id = %s
                """, (sample_id_key,))
                sample_row = cur.fetchone()
                if sample_row:
                    test_samples.append(sample_row[0])
        
        # Check if a report already exists for this test type
        report_exists = False
        existing_report = None
        
        # Check if any sample of this test type already has a report
        for sample_id_key in sample_to_test_map:
            if sample_to_test_map[sample_id_key]["item_code"] == item_code:
                cur.execute("""
                    SELECT r.report_id, r.report_no, r.status, r.file_path
                    FROM reports r
                    WHERE r.sample_id = %s
                """, (sample_id_key,))
                
                report_row = cur.fetchone()
                if report_row:
                    report_exists = True
                    existing_report = {
                        "report_id": report_row[0],
                        "report_no": report_row[1],
                        "status": report_row[2],
                        "file_path": report_row[3],
                        "covers_samples": test_samples
                    }
                    break
        
        # Check if template exists
        template_dir = "templates/reports"
        template_exists = False
        template_path = None
        template_type = None
        
        if os.path.exists(template_dir):
            for ext in ["xlsx", "docx", "pdf"]:
                potential_path = os.path.join(template_dir, f"{item_code}_Report.{ext}")
                if os.path.exists(potential_path):
                    template_exists = True
                    template_path = potential_path
                    template_type = ext
                    break
        
        return {
            "sample_id": sample_id,
            "sample_no": sample_no,
            "test_name": test_name,
            "item_code": item_code,
            "tri_id": tri_id,
            "template_available": template_exists,
            "template_path": template_path,
            "template_type": template_type,
            "test_samples": test_samples,  # All samples for this test type
            "sample_count": len(test_samples),
            "report_exists": report_exists,
            "existing_report": existing_report,
            "message": f"This sample is for {test_name}. {len(test_samples)} samples share this test type."
        }
        
    except Exception as e:
        raise HTTPException(500, f"Error: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 4. Download Report Template by Sample No - UPDATED
# ---------------------------
@router.get("/samples/by-number/{sample_no}/download-template")
def download_report_template_by_no(sample_no: str):
    """Download the Excel/Word report template for this test type"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get sample info
        cur.execute("""
            SELECT sample_id, request_id 
            FROM samples 
            WHERE sample_no = %s
        """, (sample_no,))
        
        sample_info = cur.fetchone()
        if not sample_info:
            raise HTTPException(404, f"Sample not found: {sample_no}")
        
        sample_id, request_id = sample_info
        
        # Get test distribution
        sample_to_test_map, _ = get_test_distribution_for_request(request_id, cur)
        
        # Get which test this sample belongs to
        test_info = sample_to_test_map.get(sample_id)
        if not test_info:
            raise HTTPException(400, f"Cannot determine test type for sample {sample_no}")
        
        item_code = test_info["item_code"]
        test_name = test_info["test_name"]
        
        # Look for template
        template_dir = "templates/reports"
        if not os.path.exists(template_dir):
            raise HTTPException(404, "Reports templates directory not found")
        
        possible_filenames = [
            f"{item_code}_Report.xlsx",
            f"{item_code}_Report.docx", 
            f"{item_code}_Report.pdf",
            f"{item_code}.xlsx",
            f"{item_code}.docx",
            f"{test_name.replace(' ', '_')}_Report.xlsx",
            f"{test_name.replace(' ', '_')}_Report.docx"
        ]
        
        template_path = None
        for filename in possible_filenames:
            potential_path = os.path.join(template_dir, filename)
            if os.path.exists(potential_path):
                template_path = potential_path
                break
        
        if not template_path:
            raise HTTPException(404, f"No report template found for {test_name} ({item_code})")
        
        # Return the template file for download
        filename = os.path.basename(template_path)
        return FileResponse(
            path=template_path,
            filename=filename,
            media_type='application/octet-stream'
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(500, f"Error downloading template: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 5. Upload Completed Report - SIMPLIFIED WORKING VERSION
# ---------------------------
@router.post("/upload-report")
async def upload_report(
    sample_no: str = Form(...),
    uploaded_by: int = Form(...),
    file: UploadFile = File(...),
    notes: Optional[str] = Form(None)
):
    """Upload a completed report file for a test type (covers all samples of same test)"""
    conn = get_connection()
    cur = conn.cursor()
    file_path = None
    
    try:
        print(f"Starting report upload for sample: {sample_no}")
        
        # Verify sample exists
        cur.execute("SELECT sample_id, request_id FROM samples WHERE sample_no = %s", (sample_no,))
        sample_data = cur.fetchone()
        if not sample_data:
            raise HTTPException(404, f"Sample not found: {sample_no}")
        
        sample_id, request_id = sample_data
        print(f"Found sample: {sample_id}, request: {request_id}")
        
        # Get test distribution
        try:
            sample_to_test_map, test_distribution = get_test_distribution_for_request(request_id, cur)
            print(f"Test distribution loaded: {len(sample_to_test_map)} samples mapped")
        except Exception as e:
            print(f"Error in get_test_distribution_for_request: {str(e)}")
            raise HTTPException(500, f"Error processing test distribution: {str(e)}")
        
        # Get which test this sample belongs to
        test_info = sample_to_test_map.get(sample_id)
        if not test_info:
            raise HTTPException(400, f"Cannot determine test type for sample {sample_no}")
        
        item_code = test_info.get("item_code", "UNKNOWN")
        test_name = test_info.get("test_name", "Unknown Test")
        print(f"Test info: {item_code} - {test_name}")
        
        # Get all samples for this test type
        test_samples = []
        test_sample_ids = []
        for sample_id_key, test_data in sample_to_test_map.items():
            if test_data.get("item_code") == item_code:
                cur.execute("SELECT sample_no FROM samples WHERE sample_id = %s", (sample_id_key,))
                sample_row = cur.fetchone()
                if sample_row:
                    test_samples.append(sample_row[0])
                    test_sample_ids.append(sample_id_key)
        
        print(f"Found {len(test_samples)} samples for test type {item_code}: {test_samples}")
        
        # Check if report already exists for ANY of these samples
        existing_report_no = None
        for test_sample_id in test_sample_ids:
            cur.execute("SELECT report_no FROM reports WHERE sample_id = %s", (test_sample_id,))
            existing_report = cur.fetchone()
            if existing_report:
                existing_report_no = existing_report[0]
                break
        
        if existing_report_no:
            raise HTTPException(400, 
                f"A report already exists for {test_name}. "
                f"Report No: {existing_report_no}. "
                f"Please use the existing report instead of creating a new one."
            )
        
        # Generate unique report number
        report_no = generate_report_no(cur)
        print(f"Generated report number: {report_no}")
        
        # Generate unique filename
        file_extension = os.path.splitext(file.filename)[1].lower()
        if not file_extension:
            file_extension = ".docx"
        
        unique_filename = f"{report_no.replace(' ', '_')}_{item_code}_{secrets.token_hex(4)}{file_extension}"
        file_path = os.path.join(REPORTS_UPLOAD_DIR, unique_filename)
        
        # Ensure upload directory exists
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        # Save uploaded file
        print(f"Saving file to: {file_path}")
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        
        # Prepare test info with notes
        test_info_with_notes = test_name
        if notes and notes.strip():
            short_notes = notes[:100] + "..." if len(notes) > 100 else notes
            test_info_with_notes = f"{test_name} [Notes: {short_notes}]"
        
        # Insert report record for the FIRST sample
        print(f"Inserting report for sample {test_sample_ids[0]}")
        cur.execute("""
            INSERT INTO reports (
                report_no, sample_id, original_filename, 
                stored_filename, file_path, file_type, uploaded_by, status,
                covers_test_type, covers_samples
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, 'DRAFT', %s, %s)
            RETURNING report_id
        """, (
            report_no,
            test_sample_ids[0],
            file.filename,
            unique_filename,
            file_path,
            file_extension[1:] if file_extension.startswith('.') else file_extension,
            uploaded_by,
            test_info_with_notes,
            test_samples
        ))
        
        report_id = cur.fetchone()[0]
        print(f"Created main report with ID: {report_id}")
        
        # Link this report to other samples of the same test type
        for i, other_sample_id in enumerate(test_sample_ids[1:], 1):
            try:
                print(f"Linking report to sample {other_sample_id} ({i+1}/{len(test_sample_ids)})")
                cur.execute("""
                    INSERT INTO reports (
                        report_no, sample_id, original_filename, 
                        stored_filename, file_path, file_type, uploaded_by, status,
                        covers_test_type, covers_samples, linked_to_report_id
                    )
                    VALUES (%s, %s, %s, %s, %s, %s, %s, 'DRAFT', %s, %s, %s)
                """, (
                    report_no,
                    other_sample_id,
                    file.filename,
                    unique_filename,
                    file_path,
                    file_extension[1:] if file_extension.startswith('.') else file_extension,
                    uploaded_by,
                    test_info_with_notes,
                    test_samples,
                    report_id
                ))
            except Exception as link_error:
                print(f"Warning: Failed to link to sample {other_sample_id}: {link_error}")
                # Continue with other samples
        
        conn.commit()
        print("Transaction committed successfully")
        
        return {
            "message": f"Report uploaded successfully for {test_name}",
            "report_id": report_id,
            "report_no": report_no,
            "test_name": test_name,
            "item_code": item_code,
            "covers_samples": test_samples,
            "sample_count": len(test_samples),
            "status": "DRAFT",
            "next_step": "Report is in DRAFT status. Submit for supervisor review."
        }
        
    except HTTPException as http_err:
        print(f"HTTP Exception: {http_err.detail}")
        if conn:
            conn.rollback()
        if file_path and os.path.exists(file_path):
            os.remove(file_path)
        raise
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        import traceback
        traceback.print_exc()
        
        if conn:
            conn.rollback()
        if file_path and os.path.exists(file_path):
            os.remove(file_path)
        raise HTTPException(500, f"Error uploading report: {str(e)}")
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()
# ---------------------------
# 6. Get Reports with New Format - UPDATED
# ---------------------------
@router.get("/")
def get_reports(status: Optional[str] = None):
    """Get reports with optional status filter - shows which test type they cover"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        query = """
            SELECT DISTINCT ON (r.report_no)
                r.*, 
                s.sample_no,
                qi.description as test_name,
                qi.item_code,
                u.username as uploaded_by_username
            FROM reports r
            LEFT JOIN samples s ON r.sample_id = s.sample_id
            LEFT JOIN test_request_items tri ON s.request_id = tri.test_request_id
            LEFT JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
            LEFT JOIN users u ON r.uploaded_by = u.user_id
            WHERE 1=1
        """
        params = []
        
        if status and status != "ALL":
            query += " AND r.status = %s"
            params.append(status)
        
        query += " ORDER BY r.report_no, r.created_at DESC"
        
        cur.execute(query, tuple(params))
        columns = [desc[0] for desc in cur.description]
        reports = []
        
        for row in cur.fetchall():
            report_dict = dict(zip(columns, row))
            
            # Get all samples covered by this report (same report_no)
            cur.execute("""
                SELECT s.sample_no
                FROM reports r2
                JOIN samples s ON r2.sample_id = s.sample_id
                WHERE r2.report_no = %s
                ORDER BY s.sample_no
            """, (report_dict["report_no"],))
            
            covered_samples = [row[0] for row in cur.fetchall()]
            report_dict["covered_samples"] = covered_samples
            report_dict["sample_count"] = len(covered_samples)
            
            reports.append(report_dict)
        
        return reports
        
    except Exception as e:
        raise HTTPException(500, f"Error fetching reports: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 7. Get Report by Sample No - UPDATED
# ---------------------------
@router.get("/by-sample/{sample_no}")
def get_report_by_sample_no(sample_no: str):
    """Get report details by sample number - returns the combined report for the test type"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get sample and its test type
        cur.execute("""
            SELECT s.sample_id, s.request_id
            FROM samples s
            WHERE s.sample_no = %s
        """, (sample_no,))
        
        sample_row = cur.fetchone()
        if not sample_row:
            raise HTTPException(404, f"Sample not found: {sample_no}")
        
        sample_id, request_id = sample_row
        
        # Get test distribution
        sample_to_test_map, _ = get_test_distribution_for_request(request_id, cur)
        
        # Get which test this sample belongs to
        test_info = sample_to_test_map.get(sample_id)
        if not test_info:
            raise HTTPException(400, f"Cannot determine test type for sample {sample_no}")
        
        item_code = test_info["item_code"]
        
        # Find report for any sample of this test type
        cur.execute("""
            SELECT r.report_id, r.report_no, r.status, r.file_path,
                   r.created_at, r.checked_at, r.approved_at,
                   u.username as uploaded_by_username,
                   uc.username as checked_by_username,
                   ua.username as approved_by_username,
                   s2.sample_no as linked_sample_no
            FROM reports r
            JOIN samples s2 ON r.sample_id = s2.sample_id
            JOIN test_request_items tri ON s2.request_id = tri.test_request_id
            JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
            LEFT JOIN users u ON r.uploaded_by = u.user_id
            LEFT JOIN users uc ON r.checked_by = uc.user_id
            LEFT JOIN users ua ON r.approved_by = ua.user_id
            WHERE qi.item_code = %s AND s2.request_id = %s
            ORDER BY r.created_at DESC
            LIMIT 1
        """, (item_code, request_id))
        
        report_row = cur.fetchone()
        if not report_row:
            raise HTTPException(404, f"No report found for test type: {item_code}")
        
        # Get all samples covered by this report (same report_no)
        report_no = report_row[1]
        cur.execute("""
            SELECT DISTINCT s.sample_no
            FROM reports r
            JOIN samples s ON r.sample_id = s.sample_id
            WHERE r.report_no = %s
            ORDER BY s.sample_no
        """, (report_no,))
        
        covered_samples = [row[0] for row in cur.fetchall()]
        
        return {
            "report_id": report_row[0],
            "report_no": report_row[1],
            "status": report_row[2],
            "file_path": report_row[3],
            "created_at": report_row[4],
            "checked_at": report_row[5],
            "approved_at": report_row[6],
            "uploaded_by_username": report_row[7],
            "checked_by_username": report_row[8],
            "approved_by_username": report_row[9],
            "linked_sample_no": report_row[10],
            "test_type": item_code,
            "covered_samples": covered_samples,
            "sample_count": len(covered_samples),
            "download_url": f"/reports/reports/{report_row[0]}/download"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(500, f"Error fetching report: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 8. Submit for Review - UPDATED (Single report)
# ---------------------------
@router.post("/reports/{report_id}/submit-for-review")
def submit_for_review(
    report_id: int,
    checked_by: int
):
    """Submit report for supervisor review"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get report details
        cur.execute("""
            SELECT report_id, report_no, status, is_locked
            FROM reports 
            WHERE report_id = %s
        """, (report_id,))
        
        report_row = cur.fetchone()
        if not report_row:
            raise HTTPException(404, "Report not found")
        
        report_id_db, report_no, status, is_locked = report_row
        
        if status != "DRAFT":
            raise HTTPException(400, f"Cannot submit - report status is {status}, not DRAFT")
        
        if is_locked:
            raise HTTPException(400, "Cannot submit - report is locked")
        
        # Update the single report
        cur.execute("""
            UPDATE reports 
            SET status = 'UNDER_REVIEW', checked_by = %s, checked_at = NOW()
            WHERE report_id = %s
            RETURNING report_id, report_no
        """, (checked_by, report_id))
        
        updated = cur.fetchone()
        if not updated:
            raise HTTPException(400, "Failed to update report")
        
        conn.commit()
        return {
            "message": "Report submitted for supervisor review", 
            "report_id": report_id_db,
            "report_no": report_no,
            "status": "UNDER_REVIEW",
            "checked_by": checked_by
        }
        
    except Exception as e:
        conn.rollback()
        raise HTTPException(500, f"Error: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 9. Approve Report - APPROVES ALL LINKED REPORTS
# ---------------------------
@router.post("/reports/{report_id}/approve")
def approve_report(
    report_id: int,
    approved_by: int
):
    """Approve and lock report - approves all linked reports"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get the report_no for this report
        cur.execute("SELECT report_no FROM reports WHERE report_id = %s", (report_id,))
        report_row = cur.fetchone()
        if not report_row:
            raise HTTPException(404, "Report not found")
        
        report_no = report_row[0]
        
        # Update ALL reports with this report_no
        cur.execute("""
            UPDATE reports 
            SET status = 'APPROVED', approved_by = %s, approved_at = NOW(), 
                is_locked = TRUE
            WHERE report_no = %s AND status = 'UNDER_REVIEW'
            RETURNING report_id, report_no
        """, (approved_by, report_no))
        
        updated_count = cur.rowcount
        if updated_count == 0:
            raise HTTPException(400, "Cannot approve - reports not under review")
        
        conn.commit()
        return {
            "message": f"{updated_count} report(s) approved and locked permanently", 
            "report_id": report_id,
            "report_no": report_no,
            "status": "APPROVED",
            "is_locked": True,
            "approved_by": approved_by,
            "updated_count": updated_count
        }
        
    except Exception as e:
        conn.rollback()
        raise HTTPException(500, f"Error: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 10. Get Report Details - UPDATED
# ---------------------------
@router.get("/reports/{report_id}")
def get_report(report_id: int):
    """Get report details - shows which samples it covers"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT r.report_id, r.report_no, r.sample_id, r.status, r.is_locked,
                   r.original_filename, r.file_path, r.file_type, r.created_at,
                   r.checked_at, r.approved_at, r.notes,
                   r.uploaded_by, r.checked_by, r.approved_by
            FROM reports r
            WHERE r.report_id = %s
        """, (report_id,))
        
        report = cur.fetchone()
        if not report:
            raise HTTPException(404, "Report not found")
        
        # Get all samples covered by this report (same report_no)
        report_no = report[1]
        cur.execute("""
            SELECT s.sample_no
            FROM reports r
            JOIN samples s ON r.sample_id = s.sample_id
            WHERE r.report_no = %s
            ORDER BY s.sample_no
        """, (report_no,))
        
        covered_samples = [row[0] for row in cur.fetchall()]
        
        return {
            "report_id": report[0],
            "report_no": report[1],
            "sample_id": report[2],
            "status": report[3],
            "is_locked": report[4],
            "original_filename": report[5],
            "file_path": report[6],
            "file_type": report[7],
            "created_at": report[8],
            "checked_at": report[9],
            "approved_at": report[10],
            "notes": report[11],
            "uploaded_by": report[12],
            "checked_by": report[13],
            "approved_by": report[14],
            "download_url": f"/reports/{report_id}/download",
            "covered_samples": covered_samples,
            "sample_count": len(covered_samples),
            "can_edit": report[3] == "DRAFT" and not report[4],
            "can_submit": report[3] == "DRAFT",
            "can_approve": report[3] == "UNDER_REVIEW"
        }
        
    except Exception as e:
        raise HTTPException(500, f"Error: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 11. NEW: Get Test Type Distribution for a Request
# ---------------------------
@router.get("/request/{request_id}/test-distribution")
def get_request_test_distribution(request_id: int):
    """Get how samples are distributed across test types for a request"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        sample_to_test_map, test_distribution = get_test_distribution_for_request(request_id, cur)
        
        # Get request info
        cur.execute("""
            SELECT request_no, project_id
            FROM test_requests 
            WHERE test_request_id = %s
        """, (request_id,))
        
        request_info = cur.fetchone()
        if not request_info:
            raise HTTPException(404, "Request not found")
        
        return {
            "request_id": request_id,
            "request_no": request_info[0],
            "project_id": request_info[1],
            "test_distribution": test_distribution,
            "total_samples": len(sample_to_test_map),
            "unique_test_types": len(test_distribution)
        }
        
    except Exception as e:
        raise HTTPException(500, f"Error: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 12. Replace Report File - UPDATES ALL LINKED REPORTS
# ---------------------------
@router.post("/reports/{report_id}/replace-file")
async def replace_report_file(
    report_id: int,
    replaced_by: int = Form(...),
    file: UploadFile = File(...),
    notes: Optional[str] = Form(None)
):
    """Replace report file with corrected version - updates all linked reports"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Check if main report can be modified
        cur.execute("""
            SELECT r.file_path, r.status, r.is_locked, r.report_no
            FROM reports r
            WHERE r.report_id = %s
        """, (report_id,))
        
        report = cur.fetchone()
        if not report:
            raise HTTPException(404, "Report not found")
        
        old_file_path, status, is_locked, report_no = report
        
        if is_locked:
            raise HTTPException(400, "Cannot replace locked report")
        
        if status != "DRAFT":
            raise HTTPException(400, "Can only replace DRAFT reports")
        
        # Save new file
        file_ext = os.path.splitext(file.filename)[1].lower()
        unique_name = f"rev_{report_no.replace(' ', '_')}_{secrets.token_hex(8)}{file_ext}"
        new_file_path = os.path.join(REPORTS_UPLOAD_DIR, unique_name)
        
        with open(new_file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        
        # Update ALL reports with this report_no
        cur.execute("""
            UPDATE reports 
            SET original_filename = %s, stored_filename = %s,
                file_path = %s, file_type = %s, notes = %s
            WHERE report_no = %s
        """, (file.filename, unique_name, new_file_path, file_ext[1:], notes, report_no))
        
        updated_count = cur.rowcount
        
        conn.commit()
        
        # Remove old file (only if it's not used by other reports)
        if os.path.exists(old_file_path):
            # Check if any other report still uses this file
            cur.execute("SELECT COUNT(*) FROM reports WHERE file_path = %s", (old_file_path,))
            if cur.fetchone()[0] == 0:
                os.remove(old_file_path)
        
        return {
            "message": f"Report file updated for {updated_count} linked reports",
            "report_id": report_id,
            "report_no": report_no,
            "replaced_by": replaced_by,
            "updated_count": updated_count
        }
        
    except HTTPException:
        conn.rollback()
        if 'new_file_path' in locals() and os.path.exists(new_file_path):
            os.remove(new_file_path)
        raise
    except Exception as e:
        conn.rollback()
        if 'new_file_path' in locals() and os.path.exists(new_file_path):
            os.remove(new_file_path)
        raise HTTPException(500, f"Error: {str(e)}")
    finally:
        cur.close()
        conn.close()


###############################################################
6. Samples Workflow
###############################################################

# samples_workflow.py - FIXED VERSION WITH AUTOMATIC TEST DETECTION
# samples_workflow.py - FIXED VERSION WITH AUTOMATIC TEST DETECTION

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime
from db import get_connection

from fastapi import UploadFile, File
import shutil
import os
import secrets
from decimal import Decimal  # ✅ Added missing import

router = APIRouter(prefix="/samples-workflow", tags=["Samples Workflow"])

WORKSHEET_TEMPLATES_DIR = "templates/worksheets"
os.makedirs(WORKSHEET_TEMPLATES_DIR, exist_ok=True)

# ---------------------------
# Helpers
# ---------------------------

def generate_sample_no(cur, request_id: int, sequence_num: int):
    """
    Generate sample number in format: GS-{date}-{request_seq}-{sequence}
    
    Example request_no: GQ-121225-01
    Example sample_no: GS-121225-01-1, GS-121225-01-2, etc.
    """
    # Get the request number and created date
    cur.execute("""
        SELECT request_no, created_at 
        FROM test_requests 
        WHERE test_request_id = %s
    """, (request_id,))
    row = cur.fetchone()
    
    if not row:
        return f"GS-{datetime.now().strftime('%d%m%y')}-REQ{request_id:04d}-{sequence_num:02d}"
    
    request_no, created_at = row
    
    # Extract date part from request_no or use created_at
    date_part = ""
    
    # Check if request_no follows GQ-DDMMYY-XX pattern
    if len(request_no) >= 9 and '-' in request_no:
        parts = request_no.split('-')
        if len(parts) >= 2:
            # Extract the date part (e.g., "121225" from "GQ-121225-01")
            date_part = parts[1]
        else:
            # Use created date if pattern not found
            date_part = created_at.strftime("%d%m%y") if created_at else datetime.now().strftime("%d%m%y")
    else:
        # Use created date
        date_part = created_at.strftime("%d%m%y") if created_at else datetime.now().strftime("%d%m%y")
    
    # Extract the sequence number from request_no (e.g., "01" from "GQ-121225-01")
    request_seq = "01"  # default
    
    if len(request_no) >= 12 and request_no.count('-') >= 2:
        try:
            request_seq = request_no.split('-')[2]
        except (IndexError, AttributeError):
            request_seq = "01"
    
    # Format: GS-{date}-{request_seq}-{sample_sequence}
    return f"GS-{date_part}-{request_seq}-{sequence_num}"


def generate_worksheet_no(cur, sample_id: int):
    year = datetime.utcnow().year
    cur.execute("""
        SELECT COUNT(*) 
        FROM worksheets 
        WHERE EXTRACT(YEAR FROM created_at) = %s
    """, (year,))
    seq = cur.fetchone()[0] + 1
    return f"WKS-{year}-{sample_id:04d}-{seq:03d}"


def generate_barcode():
    return secrets.token_hex(8).upper()


# ---------------------------
# Pydantic models - FIXED
# ---------------------------

class GenerateSamplesIn(BaseModel):
    collected_by: Optional[str] = None


class AcceptSampleIn(BaseModel):
    storage_location: Optional[str] = None
    note: Optional[str] = None


class RejectSampleIn(BaseModel):
    reason: Optional[str] = None
    inform_client: Optional[bool] = False


class GenerateWorksheetIn(BaseModel):
    technician: Optional[str] = None
    # ✅ REMOVED: quotation_item_id - System will auto-detect!


# ---------------------------
# 1) Generate Samples from a Test Request
# ---------------------------
@router.post("/generate-samples-by-request-no/{request_no}")
def generate_samples_by_request_no(request_no: str, payload: GenerateSamplesIn):
    conn = get_connection()
    cur = conn.cursor()

    try:
        # Find test request by request_no instead of test_request_id
        cur.execute("""
            SELECT test_request_id, project_id 
            FROM test_requests 
            WHERE request_no = %s
        """, (request_no,))
        req = cur.fetchone()
        if not req:
            raise HTTPException(404, f"Test request with number '{request_no}' not found")

        test_request_id, project_id = req

        # get all test_request_items with their details
        cur.execute("""
            SELECT tri.tri_id, tri.quotation_item_id, tri.quantity,
                   qi.item_code, qi.description
            FROM test_request_items tri
            JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
            WHERE tri.test_request_id = %s
            ORDER BY tri.tri_id
        """, (test_request_id,))
        items = cur.fetchall()

        if not items:
            raise HTTPException(400, "This request has no items")

        created_samples = []
        test_assignments = []

        # ✅ FIXED: Moved the loop inside the function
        # Create one sample for EACH test item
        for tri_id, quotation_item_id, qty, item_code, description in items:
            # For each quantity of this test item, create a sample
            for i in range(qty):
                # Calculate sequence number
                sample_sequence = len(created_samples) + 1
                
                # ✅ Use new format
                sample_no = generate_sample_no(cur, test_request_id, sample_sequence)

                cur.execute("""
                    INSERT INTO samples (sample_no, request_id, collected_by, received_date, status)
                    VALUES (%s, %s, %s, NULL, 'PENDING')
                    RETURNING sample_id
                """, (sample_no, test_request_id, payload.collected_by))

                new_sample_id = cur.fetchone()[0]
                created_samples.append(new_sample_id)
                
                # Record which test this sample is for
                test_assignments.append({
                    "sample_id": new_sample_id,
                    "sample_no": sample_no,  # ✅ This now contains the new format
                    "assigned_test": item_code,
                    "test_name": description,
                    "tri_id": tri_id,
                    "sequence": sample_sequence  # ✅ Added sequence number
                })

        conn.commit()

        return {
            "message": f"Samples generated for request {request_no} - One sample per test",
            "count": len(created_samples),
            "test_request_id": test_request_id,
            "request_no": request_no,
            "sample_ids": created_samples,
            "test_distribution": test_assignments
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()


# ---------------------------
# 2) Accept sample
# ---------------------------

@router.post("/samples/{sample_id}/accept")
def accept_sample(sample_id: int, payload: AcceptSampleIn):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            SELECT sample_id, sample_no, request_id 
            FROM samples 
            WHERE sample_id = %s
        """, (sample_id,))
        row = cur.fetchone()

        if not row:
            raise HTTPException(404, "Sample not found")

        _, existing_sample_no, request_id = row

        sample_no = existing_sample_no or generate_sample_no(cur, request_id)
        barcode = generate_barcode()

        cur.execute("""
            UPDATE samples
            SET sample_no = %s,
                barcode = %s,
                received_date = NOW(),
                status = 'ACCEPTED',
                storage_location = COALESCE(%s, storage_location)
            WHERE sample_id = %s
            RETURNING sample_no, barcode
        """, (sample_no, barcode, payload.storage_location, sample_id))

        updated = cur.fetchone()

        conn.commit()

        return {
            "message": "Sample accepted",
            "sample_id": sample_id,
            "sample_no": updated[0],
            "barcode": updated[1]
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()



# ---------------------------
# 3) Reject sample
# ---------------------------

@router.post("/samples/{sample_id}/reject")
def reject_sample(sample_id: int, payload: RejectSampleIn):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("SELECT sample_id FROM samples WHERE sample_id = %s", (sample_id,))
        if cur.fetchone() is None:
            raise HTTPException(404, "Sample not found")

        cur.execute("""
            UPDATE samples
            SET status = 'REJECTED',
                reason_rejected = %s,
                received_date = NOW()
            WHERE sample_id = %s
        """, (payload.reason, sample_id))

        conn.commit()
        return {"message": "Sample rejected"}

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))

    finally:
        cur.close()
        conn.close()

@router.post("/samples/{sample_id}/generate-worksheet")
def generate_worksheet(sample_id: int, payload: GenerateWorksheetIn):
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # FIRST: Determine which test is assigned to this specific sample
        # Get sample's position in the request and assign appropriate test
        
        # 1. Get sample info
        cur.execute("""
            SELECT s.sample_id, s.sample_no, s.request_id
            FROM samples s
            WHERE s.sample_id = %s
        """, (sample_id,))
        
        sample_row = cur.fetchone()
        if not sample_row:
            raise HTTPException(404, f"Sample {sample_id} not found")
        
        sample_id_db, sample_no, request_id = sample_row
        
        # 2. Get all tests for this request
        cur.execute("""
            SELECT tri.tri_id, qi.item_id, qi.item_code, qi.description, 
                   qi.test_standard, qi.unit_rate, tri.quantity
            FROM test_request_items tri
            JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
            WHERE tri.test_request_id = %s
            ORDER BY tri.tri_id
        """, (request_id,))
        
        all_tests = cur.fetchall()
        if not all_tests:
            raise HTTPException(400, "No tests found for this request")
        
        # 3. Get all samples for this request
        cur.execute("""
            SELECT sample_id 
            FROM samples 
            WHERE request_id = %s
            ORDER BY sample_id
        """, (request_id,))
        
        all_samples = [row[0] for row in cur.fetchall()]
        
        # 4. Find this sample's position in the sequence
        try:
            sample_position = all_samples.index(sample_id)
        except ValueError:
            sample_position = -1
        
        # 5. Determine which test this sample gets
        # Each sample gets one test based on its position
        test_index = 0
        assigned_test = None
        
        # Distribute tests to samples
        test_start_index = 0
        for test_data in all_tests:
            tri_id, item_id, item_code, description, test_standard, unit_rate, quantity = test_data
            
            # Check if this sample falls within the range for this test
            # Example: Test 1 has quantity=3 -> samples 0,1,2 get Test 1
            test_end_index = test_start_index + quantity - 1
            
            if test_start_index <= sample_position <= test_end_index:
                assigned_test = test_data
                break
            
            test_start_index += quantity
        
        if not assigned_test:
            # Fallback: use modulo distribution
            test_index = sample_position % len(all_tests)
            assigned_test = all_tests[test_index]
        
        tri_id, item_id, item_code, description, test_standard, unit_rate, quantity = assigned_test
        
        # 6. Check if worksheet already exists for this sample AND this specific test
        cur.execute("""
            SELECT worksheet_id, worksheet_no 
            FROM worksheets 
            WHERE sample_id = %s AND quotation_item_id = %s
        """, (sample_id, item_id))
        
        existing = cur.fetchone()
        if existing:
            raise HTTPException(400, 
                f"Worksheet {existing[1]} already exists for this sample/test combination. "
                f"Worksheet ID: {existing[0]}"
            )
        
        # 7. Generate worksheet number
        year = datetime.utcnow().year
        cur.execute("""
            SELECT COUNT(*) 
            FROM worksheets 
            WHERE EXTRACT(YEAR FROM created_at) = %s
        """, (year,))
        seq = cur.fetchone()[0] + 1
        worksheet_no = f"WKS-{year}-{sample_id:04d}-{seq:03d}"
        
        # 8. Check if template exists
        template_available = False
        template_path = None
        
        if item_code and os.path.exists(WORKSHEET_TEMPLATES_DIR):
            for ext in ["xlsx", "xls", "docx", "pdf"]:
                template_filename = f"{item_code}.{ext}"
                potential_path = os.path.join(WORKSHEET_TEMPLATES_DIR, template_filename)
                if os.path.exists(potential_path):
                    template_available = True
                    template_path = potential_path
                    break
        
        # 9. Create worksheet
        cur.execute("""
            INSERT INTO worksheets (
                worksheet_no, sample_id, quotation_item_id, test_name,
                standard, unit_rate, quantity, technician, status, created_at
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, 'GENERATED', NOW())
            RETURNING worksheet_id
        """, (
            worksheet_no, sample_id, item_id, description,
            test_standard, float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate,
            1,  # Each worksheet is for 1 test on 1 sample
            payload.technician or "Lab Technician"
        ))
        
        worksheet_id_new = cur.fetchone()[0]
        
        conn.commit()
        
        return {
            "message": f"Worksheet generated for {description}",
            "worksheet_id": worksheet_id_new,
            "worksheet_no": worksheet_no,
            "sample_id": sample_id,
            "sample_no": sample_no,
            "test_name": description,
            "item_code": item_code,
            "test_standard": test_standard,
            "status": "GENERATED",
            "assigned_test": item_code,  # Explicitly show assigned test
            "template_available": template_available,
            "next_step": "Download template, edit, and upload completed worksheet" if template_available else "Create worksheet manually and upload"
        }
        
    except HTTPException:
        conn.rollback()
        raise
    except Exception as e:
        conn.rollback()
        raise HTTPException(500, f"Error generating worksheet: {str(e)}")
    finally:
        cur.close()
        conn.close() 
@router.get("/pending-samples")
def get_pending_samples():
    """Get all samples with PENDING status - SIMPLIFIED VERSION"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # SIMPLIFIED QUERY - Get basic sample info first
        cur.execute("""
            SELECT 
                s.sample_id,
                s.sample_no,
                s.request_id,
                s.collected_by,
                s.received_date,
                s.status,
                s.reason_rejected,
                s.barcode,
                s.storage_location,
                tr.request_no
            FROM samples s
            JOIN test_requests tr ON s.request_id = tr.test_request_id
            WHERE s.status = 'PENDING'
            ORDER BY s.sample_id DESC
        """)
        
        samples = cur.fetchall()
        
        result = []
        for sample in samples:
            sample_id, sample_no, request_id, collected_by, received_date, status, reason_rejected, barcode, storage_location, request_no = sample
            
            # For each sample, find which test it should get
            # Get all tests for this request
            cur.execute("""
                SELECT tri.tri_id, qi.item_code, qi.description, tri.quantity,
                       ROW_NUMBER() OVER (ORDER BY tri.tri_id) as test_seq
                FROM test_request_items tri
                JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
                WHERE tri.test_request_id = %s
                ORDER BY tri.tri_id
            """, (request_id,))
            
            tests = cur.fetchall()
            
            # Get all samples for this request
            cur.execute("""
                SELECT sample_id, 
                       ROW_NUMBER() OVER (ORDER BY sample_id) as sample_seq
                FROM samples 
                WHERE request_id = %s AND status = 'PENDING'
                ORDER BY sample_id
            """, (request_id,))
            
            all_samples = cur.fetchall()
            
            # Find this sample's position
            sample_position = None
            for s in all_samples:
                if s[0] == sample_id:
                    sample_position = s[1]
                    break
            
            assigned_test = "Not Assigned"
            test_name = "No test name"
            
            if sample_position and tests:
                # Distribute tests to samples in order
                # Sample 1 gets test 1, Sample 2 gets test 2, etc.
                # If more samples than tests, wrap around
                test_index = (sample_position - 1) % len(tests)
                _, item_code, description, _, _ = tests[test_index]
                assigned_test = item_code or "Not Assigned"
                test_name = description or "No test name"
            
            result.append({
                "sample_id": sample_id,
                "sample_no": sample_no,
                "request_id": request_id,
                "collected_by": collected_by,
                "received_date": received_date,
                "status": status,
                "reason_rejected": reason_rejected,
                "barcode": barcode,
                "storage_location": storage_location,
                "request_no": request_no,
                "assigned_test": assigned_test,
                "test_name": test_name
            })
        
        return result
        
    except Exception as e:
        raise HTTPException(500, f"Database error: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# 5) Debug endpoint to check worksheet data - FIXED
# ---------------------------

@router.get("/debug/worksheet/{sample_id}")
def debug_worksheet_data(sample_id: int):
    """Debug endpoint to check what data would be used for worksheet generation"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get sample info
        cur.execute("""
            SELECT s.sample_id, s.sample_no, s.request_id,
                   tr.test_request_id, tr.request_no
            FROM samples s
            JOIN test_requests tr ON s.request_id = tr.test_request_id
            WHERE s.sample_id = %s
        """, (sample_id,))
        
        sample_info = cur.fetchone()
        if not sample_info:
            raise HTTPException(404, "Sample not found")
        
        sample_id_db, sample_no, request_id, test_request_id, request_no = sample_info
        
        # Get ALL tests for this request
        cur.execute("""
            SELECT qi.item_id, qi.item_code, qi.description, qi.test_standard, qi.unit_rate,
                   tri.quantity as requested_quantity, tri.tri_id
            FROM quotation_items qi
            JOIN test_request_items tri ON qi.item_id = tri.quotation_item_id
            WHERE tri.test_request_id = %s
            ORDER BY tri.tri_id
        """, (test_request_id,))
        
        all_tests = cur.fetchall()
        
        # Get all samples for this request
        cur.execute("""
            SELECT sample_id 
            FROM samples 
            WHERE request_id = %s
            ORDER BY sample_id
        """, (request_id,))
        
        all_samples = [row[0] for row in cur.fetchall()]
        
        # Find which test this sample should get
        try:
            sample_position = all_samples.index(sample_id)
        except ValueError:
            sample_position = -1
        
        # Determine assigned test
        assigned_test_info = None
        if all_tests and sample_position >= 0:
            test_start_index = 0
            for test_data in all_tests:
                item_id, item_code, description, test_standard, unit_rate, quantity, tri_id = test_data
                
                test_end_index = test_start_index + quantity - 1
                
                if test_start_index <= sample_position <= test_end_index:
                    assigned_test_info = {
                        "item_id": item_id,
                        "item_code": item_code,
                        "description": description,
                        "test_standard": test_standard,
                        "unit_rate": float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate,
                        "tri_id": tri_id,
                        "quantity": quantity
                    }
                    break
                
                test_start_index += quantity
            
            # Fallback
            if not assigned_test_info and all_tests:
                test_index = sample_position % len(all_tests)
                item_id, item_code, description, test_standard, unit_rate, quantity, tri_id = all_tests[test_index]
                assigned_test_info = {
                    "item_id": item_id,
                    "item_code": item_code,
                    "description": description,
                    "test_standard": test_standard,
                    "unit_rate": float(unit_rate) if isinstance(unit_rate, Decimal) else unit_rate,
                    "tri_id": tri_id,
                    "quantity": quantity
                }
        
        # Get existing worksheets for this sample
        cur.execute("""
            SELECT w.worksheet_id, w.worksheet_no, w.test_name, w.standard, w.created_at, qi.item_code
            FROM worksheets w
            LEFT JOIN quotation_items qi ON w.quotation_item_id = qi.item_id
            WHERE w.sample_id = %s
        """, (sample_id,))
        
        existing_worksheets = cur.fetchall()
        
        return {
            "sample_info": {
                "sample_id": sample_id_db,
                "sample_no": sample_no,
                "request_id": request_id,
                "test_request_id": test_request_id,
                "request_no": request_no,
                "position_in_request": sample_position + 1 if sample_position >= 0 else None,
                "total_samples_in_request": len(all_samples)
            },
            "assigned_test": assigned_test_info,  # ✅ This shows the specific test for THIS sample
            "all_tests_in_request": [
                {
                    "item_id": item[0],
                    "item_code": item[1],
                    "description": item[2],
                    "test_standard": item[3],
                    "unit_rate": float(item[4]) if isinstance(item[4], Decimal) else item[4],
                    "requested_quantity": item[5],
                    "tri_id": item[6]
                }
                for item in all_tests
            ],
            "existing_worksheets": [
                {
                    "worksheet_id": ws[0],
                    "worksheet_no": ws[1],
                    "test_name": ws[2],
                    "standard": ws[3],
                    "created_at": ws[4],
                    "item_code": ws[5]
                }
                for ws in existing_worksheets
            ]
        }
        
    except Exception as e:
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()




@router.post("/worksheets/{worksheet_id}/upload")
async def upload_worksheet_file(
    worksheet_id: int,
    worksheet_file: UploadFile = File(...)
):
    """Upload a custom worksheet file"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Check if worksheet exists
        cur.execute("SELECT worksheet_id, test_name FROM worksheets WHERE worksheet_id = %s", (worksheet_id,))
        if not cur.fetchone():
            raise HTTPException(404, f"Worksheet {worksheet_id} not found")
        
        # Get item_code for naming
        cur.execute("""
            SELECT qi.item_code
            FROM worksheets w
            LEFT JOIN samples s ON w.sample_id = s.sample_id
            LEFT JOIN test_requests tr ON s.request_id = tr.test_request_id
            LEFT JOIN test_request_items tri ON tr.test_request_id = tri.test_request_id
            LEFT JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
            WHERE w.worksheet_id = %s
            LIMIT 1
        """, (worksheet_id,))
        
        item_row = cur.fetchone()
        item_code = item_row[0] if item_row else f"worksheet_{worksheet_id}"
        
        # Determine file extension
        file_ext = os.path.splitext(worksheet_file.filename)[1]
        if not file_ext:
            file_ext = ".pdf"  # default to pdf
        
        # Create filename
        filename = f"{item_code}{file_ext}"
        file_path = os.path.join(WORKSHEET_TEMPLATES_DIR, filename)
        
        # Save the file
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(worksheet_file.file, buffer)
        
        # Update worksheet record
        cur.execute("""
            UPDATE worksheets 
            SET template_path = %s, updated_at = NOW()
            WHERE worksheet_id = %s
        """, (file_path, worksheet_id))
        
        conn.commit()
        
        return {
            "message": "Worksheet file uploaded successfully",
            "worksheet_id": worksheet_id,
            "filename": filename,
            "file_path": file_path,
            "file_size": os.path.getsize(file_path)
        }
        
    except Exception as e:
        conn.rollback()
        raise HTTPException(500, f"Error uploading worksheet: {str(e)}")
    finally:
        cur.close()
        conn.close()


# Add to samples_workflow.py
from fastapi.responses import FileResponse
import os

@router.get("/worksheets/{worksheet_id}/download")
def download_worksheet(worksheet_id: int):
    """Download the worksheet file - FIXED"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # First check template_path in worksheets table
        cur.execute("""
            SELECT w.worksheet_no, w.template_path, w.test_name, s.sample_no, w.status
            FROM worksheets w
            JOIN samples s ON w.sample_id = s.sample_id
            WHERE w.worksheet_id = %s
        """, (worksheet_id,))
        
        worksheet = cur.fetchone()
        if not worksheet:
            raise HTTPException(404, "Worksheet not found")
        
        worksheet_no, template_path, test_name, sample_no, status = worksheet
        
        # Check if file exists via template_path
        if template_path and os.path.exists(template_path):
            # Get original filename from template_path
            original_filename = os.path.basename(template_path)
            # Create a nice download filename
            download_filename = f"{sample_no}_{worksheet_no}_{test_name.replace(' ', '_')}{os.path.splitext(original_filename)[1]}"
            
            return FileResponse(
                path=template_path,
                filename=download_filename,
                media_type='application/octet-stream'
            )
        
        # Check worksheet_uploads table as fallback
        try:
            cur.execute("""
                SELECT file_path, original_filename 
                FROM worksheet_uploads 
                WHERE worksheet_id = %s 
                ORDER BY uploaded_at DESC 
                LIMIT 1
            """, (worksheet_id,))
            
            upload = cur.fetchone()
            if upload and os.path.exists(upload[0]):
                file_path, original_filename = upload
                download_filename = f"{sample_no}_{worksheet_no}_{test_name.replace(' ', '_')}{os.path.splitext(original_filename)[1]}"
                
                return FileResponse(
                    path=file_path,
                    filename=download_filename,
                    media_type='application/octet-stream'
                )
        except Exception as e:
            print(f"Note: worksheet_uploads table query failed: {e}")
        
        # No file found
        return {
            "has_file": False,
            "message": "No worksheet file uploaded yet. Please upload the completed worksheet first.",
            "worksheet_id": worksheet_id,
            "worksheet_no": worksheet_no,
            "sample_no": sample_no,
            "test_name": test_name,
            "status": status
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(500, f"Download error: {str(e)}")
    finally:
        cur.close()
        conn.close()


# Add to samples_workflow.py
@router.get("/recent-samples")
def get_recent_samples(limit: int = 5):
    """Get most recent samples for auto-complete suggestions"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # SIMPLIFIED query - Get basic sample info first
        cur.execute("""
            SELECT 
                s.sample_id,
                s.sample_no,
                s.status,
                s.barcode,
                tr.request_no,
                s.request_id
            FROM samples s
            JOIN test_requests tr ON s.request_id = tr.test_request_id
            WHERE s.status IN ('PENDING', 'ACCEPTED')
            ORDER BY s.sample_id DESC
            LIMIT %s
        """, (limit,))
        
        rows = cur.fetchall()
        
        result = []
        for row in rows:
            sample_id, sample_no, status, barcode, request_no, request_id = row
            
            # Use a separate query to determine assigned test
            assigned_test = "Test not assigned"
            
            # Get all tests for this request
            cur.execute("""
                SELECT qi.item_code, qi.description, tri.quantity, tri.tri_id
                FROM test_request_items tri
                JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
                WHERE tri.test_request_id = %s
                ORDER BY tri.tri_id
            """, (request_id,))
            
            all_tests = cur.fetchall()
            
            if all_tests:
                # Get all samples for this request
                cur.execute("""
                    SELECT sample_id 
                    FROM samples 
                    WHERE request_id = %s
                    ORDER BY sample_id
                """, (request_id,))
                
                all_samples = [r[0] for r in cur.fetchall()]
                
                # Find this sample's position
                try:
                    sample_position = all_samples.index(sample_id)
                except ValueError:
                    sample_position = -1
                
                # Determine which test this sample gets
                if sample_position >= 0:
                    test_start_index = 0
                    for test_data in all_tests:
                        item_code, description, quantity, tri_id = test_data
                        
                        test_end_index = test_start_index + quantity - 1
                        
                        if test_start_index <= sample_position <= test_end_index:
                            assigned_test = description
                            break
                        
                        test_start_index += quantity
                    
                    # Fallback
                    if assigned_test == "Test not assigned":
                        test_index = sample_position % len(all_tests)
                        item_code, description, quantity, tri_id = all_tests[test_index]
                        assigned_test = description
            
            result.append({
                "sample_id": sample_id,
                "sample_no": sample_no,
                "status": status,
                "barcode": barcode,
                "request_no": request_no,
                "assigned_test": assigned_test
            })
        
        return result
        
    except Exception as e:
        raise HTTPException(500, f"Error fetching recent samples: {str(e)}")
    finally:
        cur.close()
        conn.close()


@router.get("/samples/{sample_id}/download-template")
def download_worksheet_template(sample_id: int):
    """Download the worksheet template for this sample"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        # Get sample and its assigned test using the SAME LOGIC as other endpoints
        # 1. Get sample info
        cur.execute("""
            SELECT s.sample_id, s.sample_no, s.request_id
            FROM samples s
            WHERE s.sample_id = %s
        """, (sample_id,))
        
        sample_row = cur.fetchone()
        if not sample_row:
            raise HTTPException(404, f"Sample {sample_id} not found")
        
        sample_id_db, sample_no, request_id = sample_row
        
        # 2. Get all tests for this request
        cur.execute("""
            SELECT qi.item_id, qi.item_code, qi.description, tri.quantity, tri.tri_id
            FROM test_request_items tri
            JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
            WHERE tri.test_request_id = %s
            ORDER BY tri.tri_id
        """, (request_id,))
        
        all_tests = cur.fetchall()
        if not all_tests:
            raise HTTPException(400, "No tests found for this request")
        
        # 3. Get all samples for this request
        cur.execute("""
            SELECT sample_id 
            FROM samples 
            WHERE request_id = %s
            ORDER BY sample_id
        """, (request_id,))
        
        all_samples = [row[0] for row in cur.fetchall()]
        
        # 4. Find this sample's position
        try:
            sample_position = all_samples.index(sample_id)
        except ValueError:
            raise HTTPException(400, f"Sample {sample_id} not found in request {request_id}")
        
        # 5. Determine which test this sample gets (same logic as generate_worksheet)
        item_code = None
        test_name = None
        
        test_start_index = 0
        for test_data in all_tests:
            item_id, test_item_code, description, quantity, tri_id = test_data
            
            test_end_index = test_start_index + quantity - 1
            
            if test_start_index <= sample_position <= test_end_index:
                item_code = test_item_code
                test_name = description
                break
            
            test_start_index += quantity
        
        # Fallback
        if not item_code and all_tests:
            test_index = sample_position % len(all_tests)
            item_id, item_code, description, quantity, tri_id = all_tests[test_index]
            test_name = description
        
        if not item_code:
            raise HTTPException(400, f"Cannot determine assigned test for sample {sample_id}")
        
        print(f"🔍 Sample {sample_id} (position {sample_position}) gets test: {item_code}")
        
        # 6. Check templates directory
        if not os.path.exists(WORKSHEET_TEMPLATES_DIR):
            print(f"❌ Templates directory doesn't exist: {WORKSHEET_TEMPLATES_DIR}")
            raise HTTPException(404, f"Templates directory not found: {WORKSHEET_TEMPLATES_DIR}")
        
        # 7. Look for template
        template_path = None
        for ext in ["xlsx", "xls", "docx", "pdf"]:
            template_filename = f"{item_code}.{ext}"
            potential_path = os.path.join(WORKSHEET_TEMPLATES_DIR, template_filename)
            print(f"🔍 Checking: {potential_path}")
            
            if os.path.exists(potential_path):
                template_path = potential_path
                print(f"✅ Found template: {template_path}")
                break
        
        if not template_path:
            # Try uppercase/lowercase variations
            for ext in ["xlsx", "xls", "docx", "pdf"]:
                for variation in [item_code, item_code.upper(), item_code.lower()]:
                    template_filename = f"{variation}.{ext}"
                    potential_path = os.path.join(WORKSHEET_TEMPLATES_DIR, template_filename)
                    print(f"🔍 Checking variation: {potential_path}")
                    
                    if os.path.exists(potential_path):
                        template_path = potential_path
                        print(f"✅ Found template (variation): {template_path}")
                        break
                if template_path:
                    break
        
        if not template_path:
            print(f"❌ No template found for item_code: {item_code}")
            # List what's in the directory
            if os.path.exists(WORKSHEET_TEMPLATES_DIR):
                files = os.listdir(WORKSHEET_TEMPLATES_DIR)
                print(f"📁 Files in templates directory: {files}")
            
            raise HTTPException(404, f"No template found for {test_name} ({item_code}). Check templates/worksheets/ directory.")
        
        # 8. Return the template file
        filename = os.path.basename(template_path)
        print(f"📤 Returning file: {filename}")
        
        return FileResponse(
            path=template_path,
            filename=filename,
            media_type='application/octet-stream'
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"❌ Error downloading template: {str(e)}")
        raise HTTPException(500, f"Error downloading template: {str(e)}")
    finally:
        cur.close()
        conn.close()


###############################################################
7. Search
###############################################################
from fastapi import APIRouter, Query
import sqlite3
import os

router = APIRouter()

# Database connection helper
def get_db_connection():
    db_path = os.path.join(os.path.dirname(__file__), "gel_lims.db")
    if not os.path.exists(db_path):
        raise FileNotFoundError(f"Database not found: {db_path}")
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn

@router.get("/search")
async def search_global(
    query: str = Query(..., min_length=3),
    limit: int = Query(7, ge=1, le=50)
):
    """
    Search across enquiries, quotations, and projects
    """
    search_term = f"%{query.lower()}%"
    conn = get_db_connection()
    cursor = conn.cursor()

    results = {"enquiries": [], "quotations": [], "projects": []}

    # --- Enquiries ---
    try:
        cursor.execute("""
            SELECT 
                e.enquiry_id,
                e.enquiry_ref,
                e.project_name,
                e.client_id,
                e.status,
                e.enquiry_date,
                e.location,
                e.notes
            FROM enquiries e
            WHERE LOWER(e.enquiry_ref) LIKE ?
               OR LOWER(e.project_name) LIKE ?
            ORDER BY e.enquiry_date DESC
            LIMIT ?
        """, (search_term, search_term, limit))
        results["enquiries"] = [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        print(f"Error querying enquiries: {e}")

    # --- Quotations ---
    try:
        cursor.execute("""
            SELECT 
                quotation_id,
                quotation_no,
                enquiry_id,
                division,
                prepared_under,
                status,
                total_amount,
                vat,
                grand_total,
                payment_terms,
                validity_days,
                created_at,
                approved_at,
                version,
                revision,
                division_id
            FROM quotations
            WHERE LOWER(quotation_no) LIKE ?
               OR LOWER(prepared_under) LIKE ?
            ORDER BY created_at DESC
            LIMIT ?
        """, (search_term, search_term, limit))
        results["quotations"] = [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        print(f"Error querying quotations: {e}")

    # --- Projects ---
    try:
        cursor.execute("""
            SELECT 
                project_id,
                project_no,
                quotation_id,
                client_id,
                project_name,
                location,
                lpo_no,
                lpo_date,
                status,
                created_at,
                division_id,
                division
            FROM projects
            WHERE LOWER(project_no) LIKE ?
               OR LOWER(project_name) LIKE ?
            ORDER BY created_at DESC
            LIMIT ?
        """, (search_term, search_term, limit))
        results["projects"] = [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        print(f"Error querying projects: {e}")

    conn.close()
    return results


###############################################################
9. Templates Processor
###############################################################

from docxtpl import DocxTemplate
from io import BytesIO
from datetime import datetime
import os
from decimal import Decimal
from typing import List, Dict, Any


class QuotationTemplateProcessor:
    def __init__(self, template_path=None):
        if template_path is None:
            raise ValueError("template_path is required")
        
        self.template_path = template_path
        if not os.path.exists(self.template_path):
            raise FileNotFoundError(f"Template not found: {self.template_path}")

    def process_quotation(self, quotation_data, client_data, items):
        doc = DocxTemplate(self.template_path)
        context = self._prepare_context(quotation_data, client_data, items)
        doc.render(context)

        output = BytesIO()
        doc.save(output)
        output.seek(0)
        return output

    def _prepare_context(self, quotation_data, client_data, items):
        """Prepare all data for template with proper empty value handling"""
        print(f"DEBUG: Starting _prepare_context")
        print(f"DEBUG: items type: {type(items)}, length: {len(items) if items else 0}")

        def safe_get(data, key, default=""):
            if isinstance(data, dict):
                value = data.get(key)
            else:
                value = getattr(data, key, None)

            if value is None or (isinstance(value, str) and value.strip() == ""):
                return default
            return value

        def format_currency(value):
            if value is None or value == 0:
                return ""
            try:
                return f"{float(value):,.2f}"
            except (ValueError, TypeError):
                return ""

        division = safe_get(quotation_data, "division")
        is_geo = division == "GEO"

        total_amount = 0.0
        items_context = []

        try:
            # ===================================================
            # GEO DIVISION → CATEGORY + SUB ITEMS
            # ===================================================
            if is_geo:
                categories = [
                    {"main_title": "Geotechnical Investigation", "subitems": []},
                    {"main_title": "Drilling & Field Works Tests", "subitems": []},
                    {"main_title": "Samples", "subitems": []},
                    {"main_title": "In-situ Testing", "subitems": []},
                    {"main_title": "Laboratory Testing", "subitems": []},
                    {"main_title": "Engineering Report", "subitems": []},
                ]

                category_keywords = [
                    ['geotechnical', 'investigation', 'test'],
                    ['drill', 'borehole', 'field', 'percussion', 'rotary'],
                    ['sample', 'specimen'],
                    ['in-situ', 'insitu', 'field test', 'penetration'],
                    ['laboratory', 'lab', 'analysis', 'chemical'],
                    ['report', 'engineering', 'document'],
                ]

                if items and isinstance(items, list):
                    for item in items:
                        description = item.get("description", "").lower()
                        unit_rate = item.get("unit_rate", 0)
                        quantity = item.get("quantity", 1)
                        amount = item.get("amount")

                        if amount is None:
                            amount = unit_rate * quantity

                        total_amount += float(amount) if amount else 0

                        category_index = 0
                        for idx, keywords in enumerate(category_keywords):
                            if any(k in description for k in keywords):
                                category_index = idx
                                break

                        categories[category_index]["subitems"].append({
                            "description": item.get("description", ""),
                            "standard": item.get("test_standard", ""),
                            "unit": item.get("unit", ""),
                            "qty": quantity,
                            "rate": unit_rate,
                            "amount": amount,
                        })

                for cat_idx, category in enumerate(categories, 1):
                    if not category["subitems"]:
                        continue

                    # Main category row
                    items_context.append({
                        "s_no": f"{cat_idx}.",
                        "description": category["main_title"],
                        "standard": "",
                        "unit": "",
                        "qty": "",
                        "rate": "",
                        "amount": "",
                    })

                    # Sub items
                    for sub_idx, sub in enumerate(category["subitems"], 1):
                        letter = chr(96 + sub_idx)
                        items_context.append({
                            "s_no": f"{cat_idx}{letter})",
                            "description": sub["description"],
                            "standard": sub["standard"],
                            "unit": sub["unit"],
                            "qty": sub["qty"],
                            "rate": format_currency(sub["rate"]),
                            "amount": format_currency(sub["amount"]),
                        })

            # ===================================================
            # NON-GEO → FLAT ITEMS ONLY (NO MAIN TITLE)
            # ===================================================
            else:
                if items and isinstance(items, list):
                    for idx, item in enumerate(items, 1):
                        unit_rate = item.get("unit_rate", 0)
                        quantity = item.get("quantity", 1)
                        amount = item.get("amount")

                        if amount is None:
                            amount = unit_rate * quantity

                        total_amount += float(amount) if amount else 0

                        items_context.append({
                            "s_no": f"{idx}.",
                            "description": item.get("description", ""),
                            "standard": item.get("test_standard", ""),
                            "unit": item.get("unit", ""),
                            "qty": quantity,
                            "rate": format_currency(unit_rate),
                            "amount": format_currency(amount),
                        })

            # ===================================================
            # TOTALS
            # ===================================================
            vat_amount = total_amount * 0.05
            grand_total = total_amount + vat_amount

            context = {
                "client_name": safe_get(client_data, "name"),
                "client_contact_person": safe_get(client_data, "contact_person"),
                "client_address": safe_get(client_data, "address"),
                "client_phone": safe_get(client_data, "phone"),
                "client_email": safe_get(client_data, "email"),

                "quotation_no": safe_get(quotation_data, "quotation_no"),
                "quotation_date": safe_get(quotation_data, "created_at", datetime.now()).strftime("%d %B, %Y"),
                "enquiry_date": safe_get(quotation_data, "enquiry_date", datetime.now()).strftime("%d %B, %Y"),
                "project_name": safe_get(quotation_data, "project_name"),
                "project_location": safe_get(quotation_data, "location"),

                "items": items_context,

                "total_testing_charges": format_currency(total_amount),
                "vat_amount": format_currency(vat_amount),
                "net_total": format_currency(grand_total),
                "net_total_words": self._amount_to_words(grand_total),

                "payment_terms": safe_get(
                    quotation_data,
                    "payment_terms",
                    "• 50% payment along with job confirmation.\n• 50% on draft report."
                ),
                "validity_days": safe_get(quotation_data, "validity_days", 30),
            }

            print(f"DEBUG: Context prepared successfully")
            print(f"DEBUG: Items count: {len(items_context)}")
            return context

        except Exception as e:
            print(f"ERROR in _prepare_context: {e}")
            raise

    def _amount_to_words(self, amount):
        """Convert amount to words (e.g., 250 → Two Hundred Fifty Only)"""
        def convert_to_words(num):
            """Convert a number less than 1000 to words"""
            if num == 0:
                return "Zero"
            
            ones = ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", 
                    "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", 
                    "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", 
                    "Nineteen"]
            tens = ["", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", 
                    "Seventy", "Eighty", "Ninety"]
            
            words = ""
            
            if num >= 100:
                words += ones[num // 100] + " Hundred"
                num %= 100
                if num > 0:
                    words += " "
            
            if num >= 20:
                words += tens[num // 10]
                if num % 10 > 0:
                    words += " " + ones[num % 10]
            elif num > 0:
                words += ones[num]
            
            return words
        
        try:
            if isinstance(amount, str):
                amount = float(amount.replace(',', ''))
            
            from decimal import Decimal, ROUND_DOWN
            amount = Decimal(str(amount)).quantize(Decimal('0.01'), rounding=ROUND_DOWN)
            
            int_part = int(amount)
            dec_part = int((amount - int_part) * 100)
            
            if int_part == 0:
                if dec_part > 0:
                    return f"{convert_to_words(dec_part)} Fils Only"
                else:
                    return "Zero Dirhams Only"
            
            words_parts = []
            
            if int_part >= 1000000:
                millions = int_part // 1000000
                words_parts.append(convert_to_words(millions) + " Million")
                int_part %= 1000000
            
            if int_part >= 1000:
                thousands = int_part // 1000
                if thousands > 0:
                    words_parts.append(convert_to_words(thousands) + " Thousand")
                int_part %= 1000
            
            if int_part > 0:
                words_parts.append(convert_to_words(int_part))
            
            words = " ".join(words_parts)
            
            result = f"{words} Dirhams"
            if dec_part > 0:
                result += f" and {convert_to_words(dec_part)} Fils"
            
            result += " Only"
            return result
            
        except (ValueError, TypeError, AttributeError) as e:
            print(f"ERROR converting amount to words: {e}, amount={amount}")
            return "Zero Dirhams Only"

###############################################################
10. Tests
###############################################################

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List
from db import get_connection
from psycopg2.extras import DictCursor

router = APIRouter(prefix="/test-requests", tags=["5. Test Requests"])

# ---------------------------
# Pydantic Models - FIXED
# ---------------------------
class TestRequestCreate(BaseModel):
    project_id: int
    requested_by: Optional[str] = None

class TestRequestItemAdd(BaseModel):
    quotation_item_id: int   # Index (1,2,3)
    quantity: Optional[int] = None  # CHANGE: Make optional

class TestRequestMultiItem(BaseModel):
    items: List[TestRequestItemAdd]

class TestRequestStatusUpdate(BaseModel):
    status: str

# ---------------------------
# Helper - Generate Test Request No
# --------------------------- 
# ---------------------------
# Helper - Generate Test Request No (NEW FORMAT)
# --------------------------- 
def generate_request_no(cur):
    # Get current date components
    now = datetime.utcnow()
    date_str = now.strftime("%d%m%y")  # DDMMYY format
    
    # Count existing requests for today
    cur.execute("""
        SELECT COUNT(*)
        FROM test_requests
        WHERE DATE(created_at) = CURRENT_DATE
    """)
    count = cur.fetchone()[0] + 1
    
    # Format the sequential number
    # 01-09, then 010, 011, 012, etc.
    if count < 10:
        seq_no = f"0{count}"
    else:
        seq_no = f"0{count}"  # This gives 010, 011, etc.
    
    return f"GQ-{date_str}-{seq_no}"

# ---------------------------
# Get All Test Requests
# ---------------------------
@router.get("/")
def get_all_test_requests():
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            SELECT 
                tr.test_request_id,
                tr.request_no,
                tr.status,
                tr.requested_by,
                tr.created_at,
                p.project_id,
                p.project_no,
                p.project_name
            FROM test_requests tr
            JOIN projects p ON tr.project_id = p.project_id
            ORDER BY tr.created_at DESC
        """)

        test_requests = [
            {
                "test_request_id": row[0],
                "request_no": row[1],
                "status": row[2],
                "requested_by": row[3],
                "created_at": row[4],
                "project_id": row[5],
                "project_no": row[6],
                "project_name": row[7]
            }
            for row in cur.fetchall()
        ]

        return test_requests

    except Exception as e:
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()

# ---------------------------
# Create Test Request - UPDATED WITH DEFAULT STATUS
# ---------------------------
@router.post("/")
def create_test_request(payload: TestRequestCreate):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("SELECT project_id FROM projects WHERE project_id = %s", (payload.project_id,))
        if cur.fetchone() is None:
            raise HTTPException(404, "Project not found")

        request_no = generate_request_no(cur)

        cur.execute("""
            INSERT INTO test_requests (project_id, request_no, requested_by, status)
            VALUES (%s, %s, %s, 'PENDING_SAMPLES')
            RETURNING test_request_id
        """, (payload.project_id, request_no, payload.requested_by))

        req_id = cur.fetchone()[0]
        conn.commit()

        return {
            "message": "Test request created",
            "test_request_id": req_id,
            "request_no": request_no
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()

# ---------------------------
# Update Test Request Status
# ---------------------------
@router.post("/{test_request_id}/status")
def update_test_request_status(test_request_id: int, payload: TestRequestStatusUpdate):
    conn = get_connection()
    cur = conn.cursor()

    try:
        valid_statuses = ['PENDING_SAMPLES', 'SAMPLES_RECEIVED', 'APPROVED', 'CANCELLED']
        if payload.status not in valid_statuses:
            raise HTTPException(400, f"Invalid status. Must be one of: {valid_statuses}")

        cur.execute("SELECT test_request_id FROM test_requests WHERE test_request_id = %s", (test_request_id,))
        if cur.fetchone() is None:
            raise HTTPException(404, "Test request not found")

        cur.execute("""
            UPDATE test_requests 
            SET status = %s, updated_at = NOW()
            WHERE test_request_id = %s
        """, (payload.status, test_request_id))

        conn.commit()

        return {
            "message": f"Test request status updated to {payload.status}",
            "test_request_id": test_request_id,
            "new_status": payload.status
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()

# ================================================================
# ADD ITEM (WITH INDEX → ACTUAL ITEM ID MAPPING) - FIXED VERSION
# ================================================================
@router.post("/{test_request_id}/items")
def add_test_item(test_request_id: int, payload: TestRequestItemAdd):
    conn = get_connection()
    cur = conn.cursor()

    try:
        # 1️⃣ Get project for this test request
        cur.execute("SELECT project_id FROM test_requests WHERE test_request_id = %s", (test_request_id,))
        row = cur.fetchone()

        if row is None:
            raise HTTPException(404, "Test request not found")

        project_id = row[0]

        # 2️⃣ Get quotation for that project
        cur.execute("SELECT quotation_id FROM projects WHERE project_id = %s", (project_id,))
        row = cur.fetchone()

        if row is None:
            raise HTTPException(404, "Project not found")

        quotation_id = row[0]

        # 3️⃣ Fetch all items for this quotation WITH THEIR QUANTITIES
        cur.execute("""
            SELECT item_id, quantity
            FROM quotation_items
            WHERE quotation_id = %s
            ORDER BY item_id
        """, (quotation_id,))

        items = cur.fetchall()  # Now each item is (item_id, quantity)

        if not items:
            raise HTTPException(404, "No quotation items found!")

        # 4️⃣ User enters INDEX — convert to REAL item_id and get quotation quantity
        user_index = payload.quotation_item_id

        if user_index < 1 or user_index > len(items):
            raise HTTPException(404, f"Invalid test index: {user_index}. Must be between 1 and {len(items)}")

        actual_item_id = items[user_index - 1][0]
        quotation_quantity = items[user_index - 1][1] or 1  # Default to 1 if null

        # 5️⃣ Use user-provided quantity OR quotation quantity
        quantity_to_use = payload.quantity if payload.quantity is not None else quotation_quantity

        # 6️⃣ Insert with the proper quantity
        cur.execute("""
            INSERT INTO test_request_items (test_request_id, quotation_item_id, quantity)
            VALUES (%s, %s, %s)
            RETURNING tri_id
        """, (test_request_id, actual_item_id, quantity_to_use))

        tri_id = cur.fetchone()[0]
        conn.commit()

        return {
            "message": "Item added",
            "tri_id": tri_id,
            "actual_item_id": actual_item_id,
            "quantity_used": quantity_to_use,
            "source": "user_input" if payload.quantity is not None else "quotation"
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, f"Error adding item: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ================================================================
# ADD MULTIPLE ITEMS (ALSO INDEX-BASED) - FIXED VERSION
# ================================================================
@router.post("/{test_request_id}/items/bulk")
def add_multiple_items(test_request_id: int, payload: TestRequestMultiItem):
    conn = get_connection()
    cur = conn.cursor()

    try:
        # 1️⃣ Get project
        cur.execute("SELECT project_id FROM test_requests WHERE test_request_id = %s", (test_request_id,))
        row = cur.fetchone()

        if row is None:
            raise HTTPException(404, "Test request not found")

        project_id = row[0]

        # 2️⃣ Get quotation
        cur.execute("SELECT quotation_id FROM projects WHERE project_id = %s", (project_id,))
        row = cur.fetchone()

        if row is None:
            raise HTTPException(404, "Project not found")

        quotation_id = row[0]

        # 3️⃣ Get list of available item_ids WITH THEIR QUANTITIES
        cur.execute("""
            SELECT item_id, quantity
            FROM quotation_items
            WHERE quotation_id = %s
            ORDER BY item_id
        """, (quotation_id,))

        items = cur.fetchall()  # Now contains (item_id, quantity)

        if not items:
            raise HTTPException(404, "No quotation items found")

        added_items = []
        quantity_details = []

        # 4️⃣ Process each item in bulk input
        for entry in payload.items:
            if entry.quotation_item_id < 1 or entry.quotation_item_id > len(items):
                raise HTTPException(404, f"Invalid test index: {entry.quotation_item_id}")

            actual_item_id = items[entry.quotation_item_id - 1][0]
            quotation_quantity = items[entry.quotation_item_id - 1][1] or 1
            
            # Use user quantity or quotation quantity
            quantity_to_use = entry.quantity if entry.quantity is not None else quotation_quantity

            cur.execute("""
                INSERT INTO test_request_items (test_request_id, quotation_item_id, quantity)
                VALUES (%s, %s, %s)
                RETURNING tri_id
            """, (test_request_id, actual_item_id, quantity_to_use))

            tri_id = cur.fetchone()[0]
            added_items.append(tri_id)
            
            quantity_details.append({
                "tri_id": tri_id,
                "item_id": actual_item_id,
                "quantity_used": quantity_to_use,
                "source": "user_input" if entry.quantity is not None else "quotation"
            })

        conn.commit()

        return {
            "message": "Items added",
            "added_item_ids": added_items,
            "quantity_details": quantity_details
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, f"Error adding items: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ================================================================
# COPY ALL ITEMS FROM QUOTATION WITH QUANTITIES
# ================================================================
@router.post("/{test_request_id}/items/copy-all")
def copy_all_items_from_quotation(test_request_id: int):
    """Copy all items from the project's quotation with their original quantities"""
    conn = get_connection()
    cur = conn.cursor()

    try:
        # 1️⃣ Get project
        cur.execute("SELECT project_id FROM test_requests WHERE test_request_id = %s", (test_request_id,))
        row = cur.fetchone()

        if row is None:
            raise HTTPException(404, "Test request not found")

        project_id = row[0]

        # 2️⃣ Get quotation
        cur.execute("SELECT quotation_id FROM projects WHERE project_id = %s", (project_id,))
        row = cur.fetchone()

        if row is None:
            raise HTTPException(404, "Project not found")

        quotation_id = row[0]

        # 3️⃣ Get all items from quotation with quantities
        cur.execute("""
            SELECT item_id, description, quantity, unit_rate
            FROM quotation_items
            WHERE quotation_id = %s
            ORDER BY item_id
        """, (quotation_id,))

        quotation_items = cur.fetchall()

        if not quotation_items:
            raise HTTPException(404, "No items in quotation to copy")

        # 4️⃣ Check if test request already has items
        cur.execute("SELECT COUNT(*) FROM test_request_items WHERE test_request_id = %s", (test_request_id,))
        existing_count = cur.fetchone()[0]
        
        if existing_count > 0:
            raise HTTPException(400, "Test request already has items. Please use add items individually.")

        # 5️⃣ Insert all items with their original quantities
        added_items = []
        for item in quotation_items:
            item_id, description, quantity, unit_rate = item
            
            cur.execute("""
                INSERT INTO test_request_items (test_request_id, quotation_item_id, quantity)
                VALUES (%s, %s, %s)
                RETURNING tri_id
            """, (test_request_id, item_id, quantity or 1))

            tri_id = cur.fetchone()[0]
            added_items.append({
                "tri_id": tri_id,
                "item_id": item_id,
                "description": description,
                "quantity": quantity or 1,
                "unit_rate": float(unit_rate) if unit_rate else 0.0
            })

        conn.commit()

        return {
            "message": f"Copied {len(added_items)} items from quotation with original quantities",
            "test_request_id": test_request_id,
            "items_copied": added_items,
            "total_items": len(added_items)
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(500, f"Error copying items: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ---------------------------
# Get Test Request Details
# ---------------------------
@router.get("/{test_request_id}")
def get_test_request(test_request_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("""
            SELECT tr.test_request_id, tr.request_no, tr.status, tr.project_id,
                   tr.requested_by, tr.created_at,
                   p.project_no, p.project_name
            FROM test_requests tr
            JOIN projects p ON tr.project_id = p.project_id
            WHERE tr.test_request_id = %s
        """, (test_request_id,))

        header = cur.fetchone()
        if not header:
            raise HTTPException(404, "Test request not found")

        # Items
        cur.execute("""
            SELECT tri.tri_id, tri.quantity,
                   qi.description, qi.test_standard, qi.unit_rate, qi.item_id
            FROM test_request_items tri
            JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
            WHERE tri.test_request_id = %s
        """, (test_request_id,))

        items = []
        for r in cur.fetchall():
            unit_rate = float(r[4]) if r[4] is not None else 0.0
            quantity = r[1] if r[1] is not None else 0
            
            items.append({
                "tri_id": r[0],
                "quantity": quantity,
                "description": r[2],
                "test_standard": r[3],
                "unit_rate": unit_rate,
                "amount": unit_rate * quantity,
                "item_id": r[5]  # Include actual item_id for reference
            })

        return {
            "test_request_id": header[0],
            "request_no": header[1],
            "status": header[2],
            "project_id": header[3],
            "requested_by": header[4],
            "created_at": header[5],
            "project_no": header[6],
            "project_name": header[7],
            "items": items
        }

    except Exception as e:
        raise HTTPException(500, str(e))
    finally:
        cur.close()
        conn.close()

@router.patch("/{test_request_id}")
def update_test_request(test_request_id: int, updated_data: dict):
    conn = get_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("SELECT test_request_id FROM test_requests WHERE test_request_id = %s", (test_request_id,))
        if not cursor.fetchone():
            raise HTTPException(404, "Test Request not found")
        
        if "requested_by" in updated_data:
            cursor.execute(
                "UPDATE test_requests SET requested_by = %s WHERE test_request_id = %s",
                (updated_data["requested_by"], test_request_id)
            )
        
        if "items" in updated_data:
            for item in updated_data["items"]:
                cursor.execute(
                    "UPDATE test_request_items SET quantity = %s WHERE tri_id = %s AND test_request_id = %s",
                    (item["quantity"], item["tri_id"], test_request_id)
                )
        
        conn.commit()
        return {"status": "success", "message": "Test Request updated"}
        
    except Exception as e:
        conn.rollback()
        raise HTTPException(500, str(e))
    finally:
        cursor.close()
        conn.close()

# ---------------------------
# Get Allowed Items (Index-Based) - ENHANCED VERSION
# ---------------------------
@router.get("/{test_request_id}/items/available")
def get_available_items(test_request_id: int):
    conn = get_connection()
    cur = conn.cursor()

    try:
        cur.execute("SELECT project_id FROM test_requests WHERE test_request_id = %s", (test_request_id,))
        row = cur.fetchone()

        if row is None:
            raise HTTPException(404, "Test request not found")

        project_id = row[0]

        cur.execute("SELECT quotation_id FROM projects WHERE project_id = %s", (project_id,))
        qrow = cur.fetchone()

        if qrow is None:
            raise HTTPException(404, "Project not found")

        quotation_id = qrow[0]

        # Include quantity from quotation_items
        cur.execute("""
            SELECT item_id, description, test_standard, quantity, unit_rate, amount
            FROM quotation_items
            WHERE quotation_id = %s
            ORDER BY item_id
        """, (quotation_id,))

        items = cur.fetchall()

        return [
            {
                "index": idx + 1,
                "item_id": r[0],
                "description": r[1],
                "test_standard": r[2],
                "quotation_quantity": r[3] or 1,  # Show original quantity from quotation
                "unit_rate": float(r[4]) if r[4] else 0.0,
                "amount": float(r[5]) if r[5] else 0.0
            }
            for idx, r in enumerate(items)
        ]

    except Exception as e:
        raise HTTPException(500, f"Error loading available items: {str(e)}")
    finally:
        cur.close()
        conn.close()

# ================================================================
# GET TEST REPORTS FOR PROJECT (For Invoice Generation)
# ================================================================
@router.get("/project/{project_id}")
def get_test_reports_for_project(project_id: int):
    """Get all test reports for a specific project - used for invoice generation"""
    conn = get_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT project_id FROM projects WHERE project_id = %s", (project_id,))
        if not cur.fetchone():
            raise HTTPException(404, "Project not found")
        
        cur.execute("""
            SELECT 
                tr.test_request_id,
                tr.request_no,
                tr.status,
                tr.created_at,
                tr.requested_by,
                COUNT(DISTINCT s.sample_id) as sample_count,
                COUNT(DISTINCT tri.tri_id) as test_count,
                COALESCE(SUM(qi.unit_rate * tri.quantity), 0) as total_amount
            FROM test_requests tr
            LEFT JOIN test_request_items tri ON tr.test_request_id = tri.test_request_id
            LEFT JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
            LEFT JOIN samples s ON tr.test_request_id = s.request_id
            WHERE tr.project_id = %s
            GROUP BY tr.test_request_id, tr.request_no, tr.status, tr.created_at, tr.requested_by
            ORDER BY tr.created_at DESC
        """, (project_id,))
        
        test_requests = []
        for row in cur.fetchall():
            test_requests.append({
                "test_request_id": row[0],
                "request_no": row[1],
                "status": row[2],
                "created_at": str(row[3]),
                "requested_by": row[4],
                "sample_count": row[5],
                "test_count": row[6],
                "total_amount": float(row[7]) if row[7] else 0.0
            })
        
        invoice_items = []
        if test_requests:
            cur.execute("""
                SELECT 
                    tr.request_no,
                    qi.description,
                    qi.test_standard,
                    qi.unit_rate,
                    tri.quantity,
                    (qi.unit_rate * tri.quantity) as amount,
                    tr.created_at
                FROM test_request_items tri
                JOIN quotation_items qi ON tri.quotation_item_id = qi.item_id
                JOIN test_requests tr ON tri.test_request_id = tr.test_request_id
                WHERE tr.project_id = %s
                ORDER BY tr.request_no, qi.description
            """, (project_id,))
            
            for idx, row in enumerate(cur.fetchall(), 1):
                invoice_items.append({
                    "index": idx,
                    "report_no": row[0],
                    "description": row[1],
                    "test_standard": row[2],
                    "unit_rate": float(row[3]) if row[3] else 0.0,
                    "quantity": row[4],
                    "amount": float(row[5]) if row[5] else 0.0,
                    "report_date": str(row[6])
                })
        
        return {
            "project_id": project_id,
            "test_requests": test_requests,
            "invoice_items": invoice_items,
            "total_test_requests": len(test_requests),
            "total_tests": sum(tr["test_count"] for tr in test_requests),
            "total_amount": sum(tr["total_amount"] for tr in test_requests)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch test reports: {str(e)}")
    finally:
        cur.close()
        conn.close()





























































